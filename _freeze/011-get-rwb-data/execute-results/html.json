{
  "hash": "b868ac8aa09e3ca55fc99955d278131d",
  "result": {
    "engine": "knitr",
    "markdown": "# Prepare data {#sec-chap011}\n\n\n\n\n\n::::: {#obj-chap011}\n:::: {.my-objectives}\n::: {.my-objectives-header}\nObjectives\n:::\n\n::: {.my-objectives-container}\n\nThe goal of this chapter is to prepare the dataset(s) I would need for my RSB Shiny dashboard. To prepare the data I need to follow several steps:\n\n- Get <a class='glossary' title='Reporters Without Borders (RWB), known by its French name Reporters sans frontières and acronym RSF, is an international non-profit and non-governmental organization headquartered in Paris, France, founded in 1985 in Montpellier by journalists Robert Ménard, Rémy Loury, Jacques Molénat, and Émilien Jubineau. It is dedicated to safeguarding the right to freedom of information and defends journalists and media personnel who are imprisoned, persecuted, or at risk for their work. The organization has consultative status at the United Nations, UNESCO, the Council of Europe, and the International Organisation of the Francophonie.'>RWB</a> datasets for all years from the [RWB website](https://rsf.org/en/index) (@sec-011-get-rwb-data).\n- Get the <a class='glossary' title='The United Nations Statistics Division (UNSD) is committed to the advancement of the global statistical system. It compiles and disseminates global statistical information, develop standards and norms for statistical activities, and support countries’ efforts to strengthen their national statistical systems.'>UNSD</a> classification system using the <a class='glossary' title='The United Nations publication “Standard Country or Area Codes for Statistical Use” was originally published as Series M, No. 49 and is now commonly referred to as the M49 standard. M49 is a country/areas classification system prepared by the Statistics Division of the United Nations Secretariat primarily for use in its publications and databases.'>M49</a> methodology. (@sec-011-get-m49)\n\n\n:::\n::::\n:::::\n\n## Get RWB data {#sec-011-get-rwb-data}\n\nThe first task is to download all datasets from the [RWB website](https://rsf.org/en/index).\n\nThere is no place where I can get an integrated harmonized dataset. The only way I found out is to go to every year’s index and to use the button \"Download this index\". Fortunately the link stem and the structure of the file name is the same for all years.\n\nExample: **<https://rsf.org/sites/default/files/import_classement/2025.csv>**. \n\nSo I just have to change the year of the <a class='glossary' title='Text files where the values are separated with commas (Comma Separated Values = CSV). These files have the file extension .csv'>CSV</a> file name.\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-011-get-rwb-data}\n: Get RWB datasets\n::::::\n:::\n::::{.my-r-code-container}\n\n<center>**Run this code chunk manually if the file(s) still needs to be downloaded.**</center>\n\n::: {#lst-011-get-rwb-data}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbase::source(file = \"R/helper.R\")\nurl <- \"https://rsf.org/sites/default/files/import_classement/\"\n\nrsf_year <- function(year) {\n    rsf_name <- paste0(url, year, \".csv\")\n    readr::read_delim(rsf_name,\n                      delim = \";\", \n                      escape_double = FALSE, \n                      trim_ws = TRUE,\n                      show_col_types = FALSE)\n}\n\n\nmy_year <- list(\n    \"2002\", \"2003\", \"2004\", \"2005\", \"2006\", \"2007\", \"2008\", \"2009\", \"2010\",\n    # 2011 is missing\n    \"2012\", \"2013\", \"2014\", \"2015\", \"2016\", \"2017\", \"2018\", \"2019\", \"2020\",\n    \"2021\", \"2022\", \"2023\", \"2024\", \"2025\")\n\nfor (i in 1:length(my_year)) {\n    my_name <- paste0(\"rsf\", my_year[[i]])\n    my_save_data_file(\"chap011/rsf\",\n                      assign(my_name,  rsf_year(my_year[[i]])),\n                      paste0(my_name, \".rds\")\n    )\n}\n```\n:::\n\n\nDownload and store datasets from RWB website\n::: \n\n<center>(*For this R code chunk is no output available*)</center>\n\n::::\n:::::\n\nThe side effect of @lst-011-get-rwb-data is a collection of data files from 2002 to 2025 (2011 missing) with the structure of `rsf<year>.rds`.\n\n## Clean RWB data\n\nA manual inspections of the RSF website and of the downloaded dataset reveals three different structures of RWB datasets. My aim is to create one dataset for the whole time range 2012-2025. Therefore I have to compare the structure of the different dataset.\n\nThe first step is to load all datasets into the R memory:\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-011-load-all-datasets}\n: Load all datasets into R memory\n::::::\n:::\n::::{.my-r-code-container}\n\n<center>**Run this code chunk manually if the file(s) still needs to be loaded into memory**</center>\n\n\n::: {.cell}\n\n```{#lst-011-load-all-datasets .r .cell-code  lst-cap=\"Load all saved RWB datasets (2002-2025, 2011 missing) into R memory\"}\nbase::source(file = \"R/helper.R\")\nmy_get_dir_files(\"data/chap011/rsf\", \"\\\\.rds$\")\n```\n:::\n\n\n***\n\n<center>(*For this R code chunk is no output available. The function has the side effect that ll files with the specified path and file extensions are loaded into the R memory.*)</center>\n\n\n::::\n:::::\n\n### Batch 1: 2022-2025\n\n#### Compare structure\n\nData frames of the years 2022-2025 contain the most complete datasets. From 2022 onwards there is a new [Methodology used for compiling the World Press Freedom Indices](https://rsf.org/en/methodology-used-compiling-world-press-freedom-index-2025) worked out by panel of experts.\n\nThey have slightly different column numbers and column names:\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-011-compare-structure-2022-2025}\n: Compare structure of the datasets 2022-2025\n::::::\n:::\n::::{.my-r-code-container}\n\n::: {.cell}\n\n```{#lst-011-compare-structure-2022-2025 .r .cell-code  lst-cap=\"Compare the structure of the datasets 2022-2025 by using the `janitor::compare_df_cols()` function\"}\njanitor::compare_df_cols(rsf2025, rsf2024, rsf2023, rsf2022)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>          column_name   rsf2025   rsf2024   rsf2023   rsf2022\n#> 1         Country_AR character character character character\n#> 2         Country_EN character character character character\n#> 3         Country_ES character character character character\n#> 4         Country_FA character character character character\n#> 5         Country_FR character character character character\n#> 6         Country_PT character character character      <NA>\n#> 7   Economic Context   numeric   numeric   numeric   numeric\n#> 8                ISO character character character character\n#> 9      Legal Context   numeric   numeric   numeric   numeric\n#> 10 Political Context   numeric   numeric   numeric   numeric\n#> 11              Rank   numeric   numeric   numeric   numeric\n#> 12    Rank evolution   numeric   numeric   numeric   numeric\n#> 13          Rank N-1   numeric   numeric   numeric   numeric\n#> 14          Rank_Eco   numeric   numeric   numeric   numeric\n#> 15          Rank_Leg   numeric   numeric   numeric   numeric\n#> 16          Rank_Pol   numeric   numeric   numeric   numeric\n#> 17          Rank_Saf   numeric   numeric   numeric   numeric\n#> 18          Rank_Soc   numeric   numeric   numeric   numeric\n#> 19            Safety   numeric   numeric   numeric   numeric\n#> 20             Score      <NA>   numeric   numeric   numeric\n#> 21        Score 2025   numeric      <NA>      <NA>      <NA>\n#> 22   Score evolution character character character   numeric\n#> 23         Score N-1   numeric   numeric   numeric   numeric\n#> 24         Situation      <NA> character      <NA>      <NA>\n#> 25    Social Context   numeric   numeric   numeric   numeric\n#> 26          Year (N)   numeric   numeric   numeric   numeric\n#> 27              Zone character character character character\n```\n\n\n:::\n:::\n\n\n::::\n:::::\n\nThe table in @lst-011-compare-structure-2022-2025 shows the differences with `<NA>` values:\n\n- **Line 06**: In 2022 are the country names in Portuguese missing. But this is not relevant for my use case as I will just use `Country_EN`. \n- **Line 20 and 21**: The column `Score 2025` in the 2025 dataset has to be renamed to `Score` to get a general name for all datasets and to match the other datasets.\n- **Line 22 and 23**: `Score evolution` and the score of the previous year (`Score N-1`) is missing in the data of 2022. The reason is that in 2021 the score calculation followed a different methodology.\n- **Line 24**: There is only in 2024 a column judging the absolute score values with five predicates (in French): Bonne situation, Situation plutôt bonne, Situation problématique, Situation difficile, Situation très grave. The values for the classifications has changed with 2022 and are documented (in English) in the already mentioned article on [Methodology 2022-2025](https://rsf.org/en/methodology-used-compiling-world-press-freedom-index-2025).\n\n\n::: {.callout-important #imp-011-methodological-considerations}\n\n###### Methodological considerations\n\nEven if the years 2022-2025 and 2013-2021 have the same scale (0-100 points) these scales measure different factors of press freedom:\n\n- **2022-2025**: global score, political context, economic context, legal context, social context and safety.\n- **2013-2021**: global score, pluralism, media independence, environment and self-censorship, legislative framework, transparency, infrastructure, abuses. (Only the global score is reported.)\n\nThere is no problem to compare ranks over these two different measure methods. But a comparison of the values is critical. To understand why this is the case, imagine the comparisons of cars: In one period we measure their maximum speed, in the other period we measure the economy of their fuel consumption. Even if we judge both measures with a scale of 0-100 they are not comparable.\n\nBut in our case, we have not measured different outcome / products but we have used different indicators to measure the same thing, namely press freedom. I believe therefore that it is feasible to compare the global score of the different measurements. To use our car example: In one period we measure the economy of the fuel consumption on the highway with a speed of 100 km/h, in the other period we compare it with a combined measure of driving in the city, on country roads and highways. Both methods gives us a measure about the economy of the fuel consumption, even if the components of the global score differ.\n\nAs the RWB methods in both periods used the same scale (0 for the worst, 100 for the best), I think it is legitimate to compare the differences between 2022 (the first year with the new method) with 2021 (the last year with the previous method). This reflection concerns the two missing columns in 2022: `Score evolution` and `Score N-1`. To bind the rows together we need to add these two columns with the appropriate values to 2022.\n\nIn graphs comparing global score values for years with different methods it would be helpful to signal this distinction with different colors, line types etc. in the same figure.\n\n:::\n\n#### Adapt 2022 dataset\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-011-add-2022-columns}\n: Add `Score N-1` and `Score evolution` to RWB dataset 2022 \n::::::\n:::\n::::{.my-r-code-container}\n\n<center>**Run this code chunk manually if the 2022 still needs to be adapted**</center>\n\n\n::: {.cell}\n\n```{#lst-011-add-2022-columns .r .cell-code  lst-cap=\"Add `Score N-1` from 2021 and compute `Score evolution` to RWB dataset 2022\"}\nrsf2021_short <- readRDS(paste0(here::here(), \"/data/chap011/rsf/rsf2021.rds\")) |> \n    dplyr::select(c(ISO, `Score N`)) |> \n    dplyr::rename(`Score N-1` = `Score N`)\n\nrsf2022 <- readRDS(paste0(here::here(), \"/data/chap011/rsf/rsf2022.rds\"))\n\n## check if columns for rsf2022 are already present\nif (!\"Score evolution\" %in% names(rsf2022)) {\n  rsf2022 <- rsf2022 |> \n    dplyr::left_join(rsf2021_short, \"ISO\") |> \n    dplyr::mutate(`Score evolution` = Score - `Score N-1`)\n\n  my_save_data_file(\"chap011/rsf\", rsf2022, \"rsf2022.rds\")\n}\n\nrsf2022\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> # A tibble: 180 × 24\n#>    ISO   Score  Rank `Political Context` Rank_Pol `Economic Context` Rank_Eco\n#>    <chr> <dbl> <dbl>               <dbl>    <dbl>              <dbl>    <dbl>\n#>  1 NOR    9265     1                9489        1               9038        1\n#>  2 DNK    9027     2                9434        2               8367        3\n#>  3 SWE    8884     3                9196        3               8766        2\n#>  4 EST    8883     4                9111        5               8197        6\n#>  5 FIN    8842     5                 904        6               8203        5\n#>  6 IRL     883     6                8924        9               7908        8\n#>  7 PRT    8707     7                9186        4               7741        9\n#>  8 CRI    8592     8                8162       17               7296       11\n#>  9 LTU    8414     9                8701       11               7216       13\n#> 10 LIE    8403    10                8036       20               6878       19\n#> # ℹ 170 more rows\n#> # ℹ 17 more variables: `Legal Context` <dbl>, Rank_Leg <dbl>,\n#> #   `Social Context` <dbl>, Rank_Soc <dbl>, Safety <dbl>, Rank_Saf <dbl>,\n#> #   Zone <chr>, Country_EN <chr>, Country_FR <chr>, Country_ES <chr>,\n#> #   Country_AR <chr>, Country_FA <chr>, `Year (N)` <dbl>, `Rank N-1` <dbl>,\n#> #   `Rank evolution` <dbl>, `Score N-1` <dbl>, `Score evolution` <dbl>\n```\n\n\n:::\n:::\n\n\n***\n\n::::\n:::::\n\n\n:::::{.my-watch}\n:::{.my-watch-header}\nInconsistent score values\n:::\n::::{.my-watch-container}\n\nA check of the computed values for `Score evalution` shows inconsistent values. Compare for instance in the 2022 dataset the value of the `Score` column  for Ireland (ISO = \"IRL\") with the rest of the first ten rows. This problem exists with all score values, as one can see in the `Poltical_context` for Finland (FIN). \n\nA further detailed examination revealed that \n\n- [The values are not within the values 0-100 because they are lacking decimal position.]{.mark} For instance the `Score` value of Norway (NOR) for 2022 is `9265` instead of `92.65`. \n- [Trailing zeros are not displayed.]{.mark} Instead of `883` for Ireland the value is `8830`, or `80.30` for the scale of 0-100. There are also some values with only two figures, representing values with *two* trailing zeros.\n- Reviewing thoroughly other years it turned out that some years [distinguishes ties with the addition of another figure added as a (silent) comma position.]{.mark} Instead of `65.487` for the USA  and `64.486` for Gambia in 2025 we have `65487` and `65486`.\n\n::::\n:::::\n\n#### Compare column types\n\nBefore we can bind the datasets 2022-2025 together we have to solve another issue. A glimpse at the data shows that for the years 2023-2025 `Score evolution` is of type `character` with comma values (e.g., `\"0,63\"`)  instead of type `double` with a decimal point (e.g., `0.63`) as used in R for decimals. To bind rows for the data of different years together we have not only to match different column names but also the types of columns.\n\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-011-column-types-2025}\n: Inspect the columns type for the RWB dataset 2025\n::::::\n:::\n::::{.my-r-code-container}\n\n::: {.cell}\n\n```{#lst-011-column-types-2025 .r .cell-code  lst-cap=\"Column types of original RWB dataset 2025\"}\nrsf2025 <- readRDS(paste0(here::here(), \"/data/chap011/rsf/rsf2025.rds\"))\ndplyr::glimpse(rsf2025)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Rows: 180\n#> Columns: 25\n#> $ ISO                 <chr> \"FIN\", \"EST\", \"NLD\", \"SWE\", \"LTU\", \"DNK\", \"IRL\", \"…\n#> $ `Score 2025`        <dbl> 8718, 8946, 8864, 8813, 8227, 8693, 8692, 8426, 83…\n#> $ Rank                <dbl> 5, 2, 3, 4, 14, 6, 7, 8, 9, 10, 1, 12, 13, 11, 15,…\n#> $ `Political Context` <dbl> 8993, 9087, 8995, 9007, 8076, 9113, 913, 8877, 857…\n#> $ Rank_Pol            <dbl> 7, 4, 6, 5, 17, 3, 2, 8, 9, 11, 1, 18, 12, 10, 13,…\n#> $ `Economic Context`  <dbl> 8054, 794, 8385, 8271, 6884, 7846, 7877, 6583, 732…\n#> $ Rank_Eco            <dbl> 4, 5, 2, 3, 15, 7, 6, 20, 9, 22, 1, 18, 17, 8, 11,…\n#> $ `Legal Context`     <dbl> 8793, 90, 8969, 9002, 8323, 8678, 8149, 8616, 8373…\n#> $ Rank_Leg            <dbl> 7, 3, 4, 2, 18, 8, 24, 9, 15, 6, 1, 5, 28, 11, 23,…\n#> $ `Social Context`    <dbl> 8387, 9161, 8805, 8499, 8539, 8385, 8725, 8674, 83…\n#> $ Rank_Soc            <dbl> 12, 1, 3, 9, 8, 13, 5, 6, 15, 4, 2, 10, 7, 23, 17,…\n#> $ Safety              <dbl> 9365, 9541, 9164, 9286, 9312, 9443, 958, 9381, 938…\n#> $ Rank_Saf            <dbl> 14, 5, 27, 18, 16, 8, 4, 13, 12, 11, 2, 3, 1, 35, …\n#> $ Zone                <chr> \"UE Balkans\", \"UE Balkans\", \"UE Balkans\", \"UE Balk…\n#> $ Country_FR          <chr> \"Finlande\", \"Estonie\", \"Pays-Bas\", \"Su\\xe8de\", \"Li…\n#> $ Country_EN          <chr> \"Finland\", \"Estonia\", \"Netherlands\", \"Sweden\", \"Li…\n#> $ Country_ES          <chr> \"Finlandia\", \"Estonia\", \"Pa\\xedses Bajos\", \"Suecia…\n#> $ Country_PT          <chr> \"Finl\\xe2ndia\", \"Est\\xf4nia\", \"Pa\\xedses Baixos\", …\n#> $ Country_AR          <chr> \"??????\", \"???????\", \"??????\", \"??????\", \"????????…\n#> $ Country_FA          <chr> \"??????\", \"??????\", \"????\", \"????\", \"???????\", \"??…\n#> $ `Year (N)`          <dbl> 2025, 2025, 2025, 2025, 2025, 2025, 2025, 2025, 20…\n#> $ `Rank N-1`          <dbl> 5, 6, 4, 3, 13, 2, 8, 7, 9, 17, 1, 15, 11, 10, 12,…\n#> $ `Rank evolution`    <dbl> 0, 4, 1, -1, -1, -4, 1, -1, 0, 7, 0, 3, -2, -1, -3…\n#> $ `Score N-1`         <dbl> 8655, 8644, 8773, 8832, 8173, 896, 8559, 859, 8401…\n#> $ `Score evolution`   <chr> \"0,63\", \"3,02\", \"0,91\", \"-0,19\", \"0,54\", \"-2,67\", …\n```\n\n\n:::\n:::\n\n\n::::\n:::::\n\n@lst-011-column-types-2025 shows the problem with `Score evolution`. By this inspection we notice that we need also to convert all `character` columns to columns of type `factor`. But we can do this later, when we bind the rows together.\n\nAnother issue we should clean up, is that some country names even in the English version are not <a class='glossary' title='UTF-8 is a character encoding system that uses between one and four eight-bit bytes to represent all valid Unicode code points. It is designed to be backward compatible with ASCII, meaning that the first 128 UTF-8 characters are identical to the ASCII characters numbered 0-127. UTF-8 has become the de facto standard character encoding for the internet and related document types, with 97.9% of websites using it by April 2023. (Brave-KI)'>UTF-8</a> encoded. This problem only concerns the 2025 dataset:\n\n- \"C�te d'Ivoire\" instead of \"Côte d'Ivoire\" in `Country_EN`\n- \"T�rkiye\"  instead of \"Türkiye\" in `Country_EN` and\n- Am�riques instead of \"Amériques\" in `Zone`.\n\nBy this occasion we learn that all regional names for *all* years in `Zone` are not in English but in French. \n\n#### Clean column structure\n\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-011-clean-columns-2022-2025}\n: Clean column structure 2022-2025\n::::::\n:::\n::::{.my-r-code-container}\n\n<center>**Run this code chunk manually if the recoded file(s) still needs to be created**</center>\n\n::: {.cell}\n\n```{#lst-011-clean-columns-2022-2025 .r .cell-code  lst-cap=\"Clean and reorganize column structure for row binding\"}\nbase::source(file = \"R/helper.R\")\nsave_path = \"chap011/rsf_rec\"\nsave_ext = \"_rec.rds\"\nload_path = paste0(here::here(), \"/data/chap011/rsf/\")\n\nrsf_batch1 <- function(df, year, path, ext) {\n    if (\"Score 2025\" %in% names(df)) {\n        df <- df |> \n            dplyr::rename(Score = `Score 2025`) |> \n            dplyr::mutate(\n                Country_EN = dplyr::case_when(\n                stringr::str_detect(Country_EN, \"d'Ivoire\") ~ \"Côte d'Ivoire\",\n                stringr::str_detect(Country_EN, \"rkiye\") ~ \"Türkiye\",\n                .default = Country_EN\n            ),\n                Zone = dplyr::if_else(stringr::str_detect(Zone, \"riques\"),\n                        \"Amériques\", Zone)\n            ) \n    }\n    if (\"Situation\" %in% names(df)) {\n        df <- dplyr::select(df, -Situation)\n    }\n    if (year %in% 2023:2025) {\n        df <- df |> \n            dplyr::mutate(`Score evolution` =\n                as.double(stringr::str_replace(`Score evolution`, \",\", \".\"))\n        )\n    }\n\n    df <- df |>\n        janitor::clean_names() |>\n        dplyr::relocate(country_en, .after = iso) |>\n        dplyr::select(-c(country_fr:country_fa)) |>\n        dplyr::relocate(year_n, .before = iso)\n    my_save_data_file(path, df, \n                      paste0(\"rsf\", year, ext))\n}\n\nget_rsf_recoded1 <- function(years, path) {\n  for (i in 1:length(years)) {\n    my_name <- paste0(path, \"rsf\", years[i], \".rds\")\n    file_name <- basename(my_name)\n    rsf_batch1(assign(\n      file_name, readRDS(my_name)),\n      years[i],\n      save_path,\n      save_ext)\n  }\n}\n\nget_rsf_recoded1(2022:2025, load_path)\n```\n:::\n\n\n***\n\n<center>(*For this R code chunk is no output available*)</center>\n\n::::\n:::::\n\n#### Clean values\n\nWe are now in the position to clean the values and bind the datasets 2022-2025 by rows together. By this occasion we will create a function because we need most of code also for the other two batches.\n\n:::::{.my-procedure}\n:::{.my-procedure-header}\n:::::: {#prp-011-clean-values-2022-2025}\n: Clean values for the datasets 2022-2025\n::::::\n:::\n::::{.my-procedure-container}\nLet's resume what we want to clean up:\n\n1. **Bind the rows of the datasets together**\n2. **Update *all* score figures**: This includes the (global) `score` but also the `political_context`, the `economic_context`, the `legal_context`, the `social_context`, the `safety` and the `score_n_1` columns. The update has to be done in a sequence of 5 steps. The correct sequence is important!\n    - Multiply all scores smaller than 100 by 100\n    - Multiply all scores smaller than 1000 by 10\n    - Divide all scores bigger than 10000 by 10\n    - Divide the new numbers by 100 to get the correct decimal scores\n    - Update `score_evolution` by subtract `score_n_1` from `score`. (This last step is only necessary for the 2022 dataset, but I will do it as a measure of precaution for all.)\n3. **Create for every score column a new factor column with five bins:** Use as bin names and for the limits the classification of the press freedom map as outlined in the [methodology article for 2022 onwards](https://rsf.org/en/methodology-used-compiling-world-press-freedom-index-2025). Use as names for these new columns the addition of `_situation` to their original score column. Reorder the new created columns from their last place to the place immediately after the score column that was indicative for the situation assessment.\n4. **Change all columns with type `character` into columns of type `factor`**\n\n\n::::\n:::::\n\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-011-clean-values-2022-2025}\n: Clean data values for the datasets 2022-22025\n::::::\n:::\n::::{.my-r-code-container}\n<center>**Run this code chunk manually if `rwb1` still needs to be created and saved**</center>\n\n\n::: {.cell}\n\n```{#lst-011-clean-values-2022-2025 .r .cell-code  lst-cap=\"Follow the procedure of @prp-011-clean-values-2022-2025 and clean values for the RWB datasets 2022-2025\"}\nbase::source(file = \"R/helper.R\")\n\n## load recoded recoded rsf dataset into memory\nmy_get_dir_files(\"data/chap011/rsf_rec\", \"\\\\.rds$\")\n\n\ndf_list1 = list(rsf2025_rec, rsf2024_rec, rsf2023_rec, rsf2022_rec)\nlapply(df_list1, my_rwb_rec)\n\nrwb1 <- dplyr::bind_rows(rwb2022, rwb2023, rwb2024, rwb2025) |>\n    dplyr::mutate(dplyr::across(dplyr::where(is.character), as.factor)) |>\n    dplyr::arrange(desc(year_n), country_en)\n\n\n########## save file\nmy_save_data_file(\"chap011/rwb\", rwb1, \"rwb1.rds\")\n```\n:::\n\n\n***\n\n<center>(*For this R code chunk is no output available*)</center>\n\n::::\n:::::\n\n### Batch 2: 2013-2021\n\n#### Compare structure\n\nWe are now going to inspect the second batch of datasets: The data form the years 2013-2021.\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-011-compare-structure-2013-2021}\n: Compare structure of selected datasets between 2013-2021\n::::::\n:::\n::::{.my-r-code-container}\n\n::: {.cell}\n\n```{#lst-011-compare-structure-2013-2021 .r .cell-code  lst-cap=\"Compare the structure of selected datasets 2013-2021 by using the `janitor::compare_df_cols()` function\"}\njanitor::compare_df_cols(rsf2021, rsf2018, rsf2016, rsf2013)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>                      column_name   rsf2021   rsf2018   rsf2016   rsf2013\n#> 1                     AR_country character character character character\n#> 2                     EN_country character character character character\n#> 3                     ES_country character character character character\n#> 4                     FA_country character character character character\n#> 5                     FR_country character character character character\n#> 6                            ISO character character character character\n#> 7                 Rank evolution   numeric   numeric   numeric   numeric\n#> 8                         Rank N   numeric   numeric   numeric   numeric\n#> 9                       Rank N-1   numeric   numeric   numeric   numeric\n#> 10               Score exactions   numeric   numeric   numeric   logical\n#> 11                       Score N   numeric   numeric   numeric   numeric\n#> 12    Score N with the exactions   numeric   numeric   logical   logical\n#> 13 Score N without the exactions   numeric   numeric   numeric   logical\n#> 14                     Score N-1   numeric   numeric   numeric   numeric\n#> 15                      Year (N)   numeric   numeric   numeric   numeric\n#> 16                          Zone character character character character\n```\n\n\n:::\n:::\n\n\n::::\n:::::\n\nThe data frames from the years 2013 to 2021 are quite different. Datasets from 2013 to 2021 have only 16 columns, because they have only the global score. All the `context` variables and the `safety` column are missing. Although from 2022 onwards the questionnaire used completely different indicators one could compare the countries over the years with their *global* scores See Methodological consideration in @imp-011-methodological-considerations. There is nothing to clean up: The `context` variable are only available in the first batch of datasets.\n\n#### Clean column structure\n\n:::::{.my-procedure}\n:::{.my-procedure-header}\n:::::: {#prp-011-clean-structure-2013-2022}\n: Clean column structure for the RWB datasets 2013-2022\n::::::\n:::\n::::{.my-procedure-container}\n\nTo clean up the column structure of the datasets 2013-2022 there are three actions necessary:\n\n1. There are with `Score exactions`, `Score N with the exactions`, `Score N without the exactions` and `Score evolution` three columns that are not present in the first batch of datasets (2022-2025). There is also a column type mismatch of numeric versus logical in the three `exactions`  columns, because in the first years of the second batch `Score N with the exactions`, `Score N without the exactions` have no (`NA`) values. Anyway: I couldn't find an explanation what the `exaction` columns measure. So I will delete these columns.\n2. Instead of the two-letter language code for the country names columns at the end (`Country_EN`), in the second batch (2013-2021) these abbreviations appear at the start the column name (`EN_country`). This is only important for the English names as I will use only the English variant of the country names. Other issues (such as the score value inconsistency) are the same in both dataset batches.\n3. The columns names for the global score and rank are `Score N` and `Rank N` instead of just `Score`and `Rank` in the first batch of datasets. I have to rename them.\n\nAdditionally there is another issue: The `Score evolution` column is missing. This column is important and easy to compute because `Score N` and `Score N-1` are present. But this change has to be done after cleaning the `Score N` and `Score N-1` values.\n\n::::\n:::::\n\n\n\n\n::: {.callout-important #imp-011-column-sequencefor-row-binding}\n###### The column sequence for row binding is irrelevant. Important is only the match of column names. \n:::\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-011-clean-columns-2013-2021}\n: Clean column structure 2013-2021\n::::::\n:::\n::::{.my-r-code-container}\n\n<center>**Run this code chunk manually if the recoded file(s) still needs to be created**</center>\n\n::: {.cell}\n\n```{#lst-011-clean-columns-2013-2021 .r .cell-code  lst-cap=\"Clean / reorganize column structure for row binding\"}\nbase::source(file = \"R/helper.R\")\nsave_path = \"chap011/rsf_rec\"\nsave_ext = \"_rec2.rds\"\nload_path = paste0(here::here(), \"/data/chap011/rsf/\")\n\n## load rsf datasets into memory\nmy_get_dir_files(\"data/chap011/rsf\", \"\\\\.rds$\")\n\nrsf_batch2 <- function(df, year, path, ext) {\n    df <-  df |> \n        dplyr::select(-contains(\"exactions\")) |>        # (1) \n        dplyr::rename(\n            Country_EN = EN_country,                    # (2)                    \n            Score = `Score N`,                          # (3)\n            Rank = `Rank N`                             # (3)\n        ) |> \n        dplyr::relocate(Country_EN, .after = ISO) |> \n        janitor::clean_names() |>\n        dplyr::select(-c(fr_country:fa_country))        # (2)\n    my_save_data_file(path, df, paste0(\"rsf\", year, ext))\n}\n\nget_rsf_recoded2 <- function(years, path) {\n  for (i in 1:length(years)) {\n    my_name <- paste0(path, \"rsf\", years[i], \".rds\")\n    file_name <- basename(my_name)\n    rsf_batch2(assign(\n      file_name, readRDS(my_name)),\n      years[i],\n      save_path,\n      save_ext)\n  }\n}\n\nget_rsf_recoded2(2013:2021, load_path)\n```\n:::\n\n\n***\n\n<center>(*For this R code chunk is no output available*)</center>\n\n::::\n:::::\n\n#### Clean values\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-011-clean-values-2013-2021}\n: Clean data values for the datasets 2013-2021\n::::::\n:::\n::::{.my-r-code-container}\n<center>**Run this code chunk manually if `rwb2` still needs to be created and saved**</center>\n\n\n::: {.cell}\n\n```{#lst-011-clean-values-2013-2021 .r .cell-code  lst-cap=\"Follow the procedure of @prp-011-clean-structure-2013-2022 and clean values for the RWB datasets 2013-2021\"}\nbase::source(file = \"R/helper.R\")\n\n## load recoded recoded rsf dataset into memory\nmy_get_dir_files(\"data/chap011/rsf_rec\", \"\\\\.rds$\")\n\n\n########### clean data second batch  \ndf_list2 = list(rsf2021_rec2, rsf2020_rec2, rsf2019_rec2, rsf2018_rec2,\n                rsf2017_rec2, rsf2016_rec2, rsf2015_rec2, rsf2014_rec2,\n                rsf2013_rec2)\nlapply(df_list2, my_rwb_rec)\n\n########### bind rows \nrwb2 <- dplyr::bind_rows(rwb2021, rwb2020, rwb2019, rwb2018,\n                rwb2017, rwb2016, rwb2015, rwb2014, rwb2013) |>\n    dplyr::mutate(dplyr::across(dplyr::where(is.character), as.factor)) |>\n    dplyr::arrange(desc(year_n), country_en)\n\n############# save file\nmy_save_data_file(\"chap011/rwb\", rwb2, \"rwb2.rds\")\n```\n:::\n\n\n***\n\n<center>(*For this R code chunk is no output available*)</center>\n\n::::\n:::::\n\n### Batch 3: 2002-2011/2012\n\n#### Compare structure\n\nThe third batch is the most easiest to clean up, because `Score N` and `Score N-1` values are not comparable with the files from the other datasets batches. The used scores for the years 2002-2012 (missing 2011) range from 0 respectively in 2011/2012 (-10) for the best to a maximum of 115.5 in 2009 for the worst situation. Therefore we also don't need the missing `Score evolution` to create and compute.\n\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-011-compare-structure-2002-2012}\n: Compare the structure of a selection of the datasets 2002-2012\n::::::\n:::\n::::{.my-r-code-container}\n\n::: {.cell}\n\n```{#lst-011-compare-structure-2002-2012 .r .cell-code  lst-cap=\"Compare the structure of a selection the datasets 2002-2012 by using the `janitor::compare_df_cols()` function\"}\njanitor::compare_df_cols(rsf2012, rsf2008, rsf2005, rsf2002)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>                      column_name   rsf2012   rsf2008   rsf2005   rsf2002\n#> 1                     AR_country character character character character\n#> 2                     EN_country character character character character\n#> 3                     ES_country character character character character\n#> 4                     FA_country character character character character\n#> 5                     FR_country character character character character\n#> 6                            ISO character character character character\n#> 7                 Rank evolution   numeric   numeric   numeric   logical\n#> 8                         Rank N   numeric   numeric   numeric   numeric\n#> 9                       Rank N-1   numeric   numeric   numeric   logical\n#> 10               Score exactions   logical   logical   logical   logical\n#> 11                       Score N   numeric   numeric character character\n#> 12    Score N with the exactions   logical   logical   logical   logical\n#> 13 Score N without the exactions   logical   logical   logical   logical\n#> 14                     Score N-1 character character character   logical\n#> 15                      Year (N) character   numeric   numeric   numeric\n#> 16                          Zone character character character character\n```\n\n\n:::\n:::\n\n\n::::\n:::::\n\n#### Clean column structure\n\nIt turned out that the data frames from 2002-2012 have exactly the same structure as the datasets from 2013-2021. But there is one big difference: The values of the columns of `Score N` and `Score N-1` are not compatible with the rest of the data. So when I am going to bind the rows of the different years together, I have to delete these columns to prevent misunderstandings. For the years 2002-2012 only the rank data can be used. \n\n\n:::::{.my-procedure}\n:::{.my-procedure-header}\n:::::: {#prp-011-clean-values-2002-2012}\n: Clean structure for the RWB dataset 2002-2012\n::::::\n:::\n::::{.my-procedure-container}\n\nThe following steps are necessary to clean up the values (and structure) of the 2002-2012\n\n\n1. Delete all columns that contain `Score`. These are:\n  - `Score`\n  - `Score N-1`\n  - `Score N without the exactions`\n  - `Score with the exactions` and\n  - `Score exactions`\n2. Rename as in the second batch of dataset `EN_country` to `Country_EN`.\n3. Rename `Rank N` to `Rank`.\n4. Delete all languages for country names with the exception of the English names.\n5. Skip the missing year 2011\n  \n  \n  \n  \n::::\n:::::\n\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-011-clean-columns-2002-2012}\n: Clean column structure 2002-2012\n::::::\n:::\n::::{.my-r-code-container}\n\n<center>**Run this code chunk manually if the recoded file(s) still needs to be created**</center>\n\n::: {.cell}\n\n```{#lst-011-clean-columns-2002-2012 .r .cell-code  lst-cap=\"Clean / reorganize column structure for row binding\"}\nbase::source(file = \"R/helper.R\")\nsave_path = \"chap011/rsf_rec\"\nsave_ext = \"_rec3.rds\"\nload_path = paste0(here::here(), \"/data/chap011/rsf/\")\n\n## load rsf datasets into memory\nmy_get_dir_files(\"data/chap011/rsf\", \"\\\\.rds$\")\n\nrsf_batch3 <- function(df, year, path, ext) {\n    df <-  df |> \n        dplyr::select(-contains(\"Score\")) |>            # (1) \n        dplyr::rename(\n            Country_EN = EN_country,                    # (2)                    \n            Rank = `Rank N`                             # (3)\n        ) |> \n        dplyr::relocate(Country_EN, .after = ISO) |> \n        janitor::clean_names() |>\n        dplyr::select(-c(fr_country:fa_country))        # (4)\n    my_save_data_file(path, df, paste0(\"rsf\", year, ext))\n}\n\nget_rsf_recoded3 <- function(years, path) {\n  for (i in 1:length(years)) {\n    if (years[i] == 2011) {next}                        # (5)\n    my_name <- paste0(path, \"rsf\", years[i], \".rds\")\n    file_name <- basename(my_name)\n    rsf_batch3(assign(\n      file_name, readRDS(my_name)),\n      years[i],\n      save_path,\n      save_ext)\n  }\n}\n\nget_rsf_recoded3(2002:2012, load_path)\n```\n:::\n\n\n***\n\n<center>(*For this R code chunk is no output available*)</center>\n\n::::\n:::::\n\n#### Clean values\n\nAfter I tried to clean up the values in @lst-011-clean-values-2002-2012 I noticed another structural problem: As data for the year 2011 are missing the dataset for 2012 have as `year` value the character string `2011-12` and is therefore not compatible with the other datasets. \n\n\n:::::{.my-procedure}\n:::{.my-procedure-header}\n:::::: {#prp-011-clean-values-2002-2012}\n: Clean values for the RWB datasets 2002-2012\n::::::\n:::\n::::{.my-procedure-container}\n\n1. Change the `year_n` values of the dataset 2012 from the character string `2011-12` to the numeric value of `2012`\n2. Change all columns of type `character` to columns of type `factor.`\n3. Sort the data by year (`year_n`) and country name (`country_en`)\n\nI applied the last two changes also to the other batches of datasets (batch 1 and 2) but didn't mention it there in appropriate sections explicitly.\n::::\n:::::\n\n\n\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-011-clean-values-2002-2013}\n: Clean data values for the datasets 2002-2013\n::::::\n:::\n::::{.my-r-code-container}\n<center>**Run this code chunk manually if `rwb3` still needs to be created and saved**</center>\n\n\n::: {.cell}\n\n```{#lst-011-clean-values-2002-2012 .r .cell-code  lst-cap=\"Follow the procedure of @prp-011-clean-values-2002-2012 and clean values for the RWB datasets 2002-2013\"}\nbase::source(file = \"R/helper.R\")\n\n## load recoded rsf dataset into memory\nmy_get_dir_files(\"data/chap011/rsf_rec\", \"\\\\.rds$\")\n\nrwb_rec3 <- function(df) {\n    for (i in seq_along(df)) {\n        if (is.character(df$year_n)) {                          # (1)\n            df <- dplyr::mutate(df, year_n = as.numeric(2012)). # (1)\n        }\n        file_name = paste0(\"rwb\", df$year_n[1])\n        assign(file_name, df, envir = globalenv())\n    }\n}\n\n\n########### clean data third batch\ndf_list3 = list(rsf2012_rec3, rsf2010_rec3, rsf2009_rec3,\n                rsf2008_rec3, rsf2007_rec3, rsf2006_rec3, rsf2005_rec3,\n                rsf2004_rec3, rsf2003_rec3, rsf2002_rec3)\nlapply(df_list3, rwb_rec3)\n\n########## bind rows\nrwb3 <- dplyr::bind_rows(rwb2012, rwb2010, rwb2009, rwb2008, rwb2007, \n                         rwb2006, rwb2005, rwb2004, rwb2003, rwb2002) |>\n    dplyr::mutate(dplyr::across(dplyr::where(is.character), as.factor)) |> # (2)\n    dplyr::arrange(desc(year_n), country_en)                               # (3)\n\n########## save file\nmy_save_data_file(\"chap011/rwb\", rwb3, \"rwb3.rds\")\n```\n:::\n\n\n***\n\n<center>(*For this R code chunk is no output available*)</center>\n\n::::\n:::::\n\n\n### All together\n\nAfter I cleaned the three different dataset batches, it is now time to finish and combine the datasaets to the one I am going to working with.\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-011-all-batches-together}\n: Bind the rows for the three cleaned batches of datasets `rwb1.rds`, `rwb2.rds` and `rwb3.rds`\n::::::\n:::\n::::{.my-r-code-container}\n\n::: {.cell}\n\n```{#lst-011-all-batches-together .r .cell-code  lst-cap=\"Bind the rows for the three cleaned batches of datasets `rwb1.rds`, `rwb2.rds` and `rwb3.rds` to the final `rwb.rds file.\"}\nbase::source(file = \"R/helper.R\")\n\n######### load cleaned batches of datasets into memory\nmy_get_dir_files(\"data/chap011/rwb\", \"\\\\.rds$\")\n\n\n########## bind rows\nrwb <- (dplyr::bind_rows(rwb1, rwb2, rwb3))\n\n\n########## save file\nmy_save_data_file(\"chap011/rwb\", rwb, \"rwb.rds\")\n```\n:::\n\n\n::::\n:::::\n\n\n\n## Get M49 {#sec-011-get-m49}\n\nTo harmonize the RWB datasets with the names of the planned country geometries for the maps I need to download an official classification system. A detailed classification system expressively developed for statistical purposes is developed by the United Nations Statistics\nDivision <a class='glossary' title='The United Nations Statistics Division (UNSD) is committed to the advancement of the global statistical system. It compiles and disseminates global statistical information, develop standards and norms for statistical activities, and support countries’ efforts to strengthen their national statistical systems.'>UNSD</a> using the <a class='glossary' title='The United Nations publication “Standard Country or Area Codes for Statistical Use” was originally published as Series M, No. 49 and is now commonly referred to as the M49 standard. M49 is a country/areas classification system prepared by the Statistics Division of the United Nations Secretariat primarily for use in its publications and databases.'>M49</a> methodology.\n\n\nM49 is officially called [Standard country or area codes for statistical use\n(M49)](https://unstats.un.org/unsd/methodology/m49/) and can be\ndownloaded manually in different languages and formats (Copy into the\nclipboard, Excel or <a class='glossary' title='Text files where the values are separated with commas (Comma Separated Values = CSV). These files have the file extension .csv'>CSV</a> from the [Overview\npage](https://unstats.un.org/unsd/methodology/m49/overview/). On the page \"Overview\" is\nno URL for an R script available, because triggering one of the buttons\ncopies or downloads the data with the help of Javascript. So I had to download the file manually or to find another location where I could download it programmatically. \n\nThe M49 specification is included in the {**ISOcodes**} package. But I am using the official file because it has countries and regions together in a form where no big recoded is necessary. \n\nI found with the <a class='glossary' title='OMNIKA DataStore is an open-access data science resource for researchers, authors, and technologists. OMNIKA Foundation is an American 501©(3) nonprofit organization that operates a digital mythological library. Almost every culture has relevant mythology that explains where we came from, why things are the way they are, and a number of other things. OMNIKA’s goal is to collect, organize, index, and quantify all of those data in one place and make them available for free. (https://omnika.org/info/about)'>OMNIKA</a> DataStore [United Nations M49 Region Codes](https://omnika.org/datastore/datasets/un-m49-region-codes) an [external source for the UNSD-M49 country classification](https://github.com/omnika-datastore/unsd-m49-standard-area-codes). For security reason I checked the two files with `base::all.equal()` to determine if those two files are identical. Yes, they are!\n\nThe UNSD M40 standard area codes are stored as Excel and CSV files. I download for reproducibility reason the CSV file.\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-011-get-m49}\n: Get M49 classification system\n::::::\n:::\n::::{.my-r-code-container}\n\n<center>**Run this code chunk manually if the file(s) still needs to be downloaded.**</center>\n\n::: {#lst-011-get-m49}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## download unsd-m49 file ############\nurl_m49 <- \"https://github.com/omnika-datastore/unsd-m49-standard-area-codes/raw/refs/heads/main/2022-09-24__CSV_UNSD_M49.csv\"\n\ndownloader::download(\n    url = url_m49,\n    destfile = \"data/m49.csv\"\n)\n\n\n## create R object ###############\nm49_raw <-\n    readr::read_delim(\n        file = \"data/m49.csv\",\n        delim = \";\", \n        escape_double = FALSE, \n        trim_ws = TRUE,\n        show_col_types = FALSE\n    )\n\nmy_save_data_file(\"chap011\", m49_raw, \"m49_raw.rds\")\n```\n:::\n\n\nDownload and store the M49 classification system \n::: \n\n<center>(*For this R code chunk is no output available*)</center>\n\n::::\n:::::\n\n\n\n## Glossary Entries {.unnumbered}\n\n\n::: {.cell}\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table\" style=\"margin-left: auto; margin-right: auto;\">\n <thead>\n  <tr>\n   <th style=\"text-align:left;\"> term </th>\n   <th style=\"text-align:left;\"> definition </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;\"> CSV </td>\n   <td style=\"text-align:left;\"> Text files where the values are separated with commas (Comma Separated Values = CSV). These files have the file extension .csv </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> M49 </td>\n   <td style=\"text-align:left;\"> The United Nations publication \"Standard Country or Area Codes for Statistical Use\" was originally published as Series M, No. 49 and is now commonly referred to as the M49 standard. M49 is a country/areas classification system prepared by the Statistics Division of the United Nations Secretariat primarily for use in its publications and databases. </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> OMNIKA </td>\n   <td style=\"text-align:left;\"> OMNIKA DataStore is an open-access data science resource for researchers, authors, and technologists. OMNIKA Foundation is an American 501(c)(3) nonprofit organization that operates a digital mythological library. Almost every culture has relevant mythology that explains where we came from, why things are the way they are, and a number of other things. OMNIKA's goal is to collect, organize, index, and quantify all of those data in one place and make them available for free. (https://omnika.org/info/about) </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> RWB </td>\n   <td style=\"text-align:left;\"> Reporters Without Borders (RWB), known by its French name Reporters sans frontières and acronym RSF, is an international non-profit and non-governmental organization headquartered in Paris, France, founded in 1985 in Montpellier by journalists Robert Ménard, Rémy Loury, Jacques Molénat, and Émilien Jubineau. It is dedicated to safeguarding the right to freedom of information and defends journalists and media personnel who are imprisoned, persecuted, or at risk for their work. The organization has consultative status at the United Nations, UNESCO, the Council of Europe, and the International Organisation of the Francophonie. </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> UNSD </td>\n   <td style=\"text-align:left;\"> The United Nations Statistics Division (UNSD) is committed to the advancement of the global statistical system. It compiles and disseminates global statistical information, develop standards and norms for statistical activities, and support countries' efforts to strengthen their national statistical systems. </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> UTF-8 </td>\n   <td style=\"text-align:left;\"> UTF-8 is a character encoding system that uses between one and four eight-bit bytes to represent all valid Unicode code points. It is designed to be backward compatible with ASCII, meaning that the first 128 UTF-8 characters are identical to the ASCII characters numbered 0-127. UTF-8 has become the de facto standard character encoding for the internet and related document types, with 97.9% of websites using it by April 2023. (Brave-KI) </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n\n------------------------------------------------------------------------\n\n## Session Info {.unnumbered}\n\n::: my-r-code\n::: my-r-code-header\nSession Info\n:::\n\n::: my-r-code-container\n\n::: {.cell}\n\n```{.r .cell-code}\nxfun::session_info()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> R version 4.5.1 (2025-06-13)\n#> Platform: aarch64-apple-darwin20\n#> Running under: macOS Sequoia 15.6.1\n#> \n#> Locale: en_US.UTF-8 / en_US.UTF-8 / en_US.UTF-8 / C / en_US.UTF-8 / en_US.UTF-8\n#> \n#> Package version:\n#>   askpass_1.2.1      base64enc_0.1.3    bslib_0.9.0        cachem_1.1.0      \n#>   cli_3.6.5          commonmark_2.0.0   compiler_4.5.1     cpp11_0.5.2       \n#>   curl_7.0.0         digest_0.6.37      dplyr_1.1.4        evaluate_1.0.5    \n#>   farver_2.1.2       fastmap_1.2.0      fontawesome_0.5.3  fs_1.6.6          \n#>   generics_0.1.4     glossary_1.0.0     glue_1.8.0         graphics_4.5.1    \n#>   grDevices_4.5.1    grid_4.5.1         here_1.0.1         highr_0.11        \n#>   hms_1.1.3          htmltools_0.5.8.1  htmlwidgets_1.6.4  httr_1.4.7        \n#>   janitor_2.2.1      jquerylib_0.1.4    jsonlite_2.0.0     kableExtra_1.4.0  \n#>   knitr_1.50         labeling_0.4.3     lifecycle_1.0.4    litedown_0.7      \n#>   lubridate_1.9.4    magrittr_2.0.3     markdown_2.0       memoise_2.0.1     \n#>   methods_4.5.1      mime_0.13          openssl_2.3.3      pillar_1.11.0     \n#>   pkgconfig_2.0.3    purrr_1.1.0        R6_2.6.1           rappdirs_0.3.3    \n#>   RColorBrewer_1.1-3 renv_1.1.5         rlang_1.1.6        rmarkdown_2.29    \n#>   rprojroot_2.1.1    rstudioapi_0.17.1  rversions_2.1.2    rvest_1.0.5       \n#>   sass_0.4.10        scales_1.4.0       selectr_0.4.2      snakecase_0.11.1  \n#>   stats_4.5.1        stringi_1.8.7      stringr_1.5.1      svglite_2.2.1     \n#>   sys_3.4.3          systemfonts_1.2.3  textshaping_1.0.1  tibble_3.3.0      \n#>   tidyr_1.3.1        tidyselect_1.2.1   timechange_0.3.0   tinytex_0.57      \n#>   tools_4.5.1        utf8_1.2.6         utils_4.5.1        vctrs_0.6.5       \n#>   viridisLite_0.4.2  withr_3.0.2        xfun_0.53          xml2_1.4.0        \n#>   yaml_2.3.10\n```\n\n\n:::\n:::\n\n:::\n:::\n\n",
    "supporting": [
      "011-get-rwb-data_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<script src=\"site_libs/kePrint-0.0.1/kePrint.js\"></script>\n<link href=\"site_libs/lightable-0.0.1/lightable.css\" rel=\"stylesheet\" />\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}