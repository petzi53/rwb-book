# Learn Leaflet {#sec-chap042}

August 17, 2025

```{r}
#| label: setup
#| results: hold
#| include: false

base::source(file = "R/helper.R")

```

:::::: {#obj-chap100}
::::: my-objectives
::: my-objectives-header
Objectives
:::

::: my-objectives-container
Learn using {**leaflet**} / leaflet.js using my RWB data as practical
example
:::
:::::
::::::

## Preliminary remark

After following [Making maps with R](https://r.geocompx.org/adv-map)
(chapter 9 of the online book [Geocomputation with
R](https://r.geocompx.org/)) it turned out in my @sec-chap041 that
[{**leaflet**}](https://rstudio.github.io/leaflet/index.html) /
[leaflet.js](https://leafletjs.com/) is the most mature and widely used
interactive mapping package in R interactive map drawing software.
{**leaflet**} has twice more downloads than {**tmap**} which is as the
moment the leading spatial geographic map tool. (See
@lst-042-mapping-packages-downloads which contains a list of downloads
for several map drawing packages.)

::: {#nte-042-new-map-package-maps .callout-note}
##### Added {**maps**} to @lst-042-mapping-packages-downloads

I just learned in the section @sec-042-data-object that {**maps**} is
another important package ranking with it download numbers in the second
place!

I added this package therefore to @lst-042-mapping-packages-downloads.
The above paragraph is not correct anymore as {**maps**} has about 50%
more downloads than {**leaflet**}.
:::

:::::: my-r-code
:::: my-r-code-header
::: {#cnj-042-mapping-packages-downloads}
: Overview of download numbers of map packages
:::
::::

::: my-r-code-container
```{r}
#| label: mapping-packages-downloads
#| lst-label: lst-042-mapping-packages-downloads
#| lst-cap: Overview of download numbers of map packages

my_pkgs_dl(
  pkgs = c(
    "tmap", 
    "plotly", 
    "mapview",
    "mapdeck",
    "googleway",
    "mapsf",
    "mapmisc",
    "leaflet",
    "Rgooglemaps",
    "ggmap",
    "mapedit",
    "ggiraph",
    "maps"
    ),
  period = "last-month", 
  days = 30
)
```
:::
::::::

Although {**leaflet**} has with about 3.000 downloads/day only about the
half of the {**plotly**} downloads it is a specialized map drawing
software whereas {**plotly**} is a general interactive web graphics
tool.

> It’s worth noting that {**plotly**} aims to be a general purpose
> visualization library, and thus, doesn’t aim to be the most fully
> featured geo-spatial visualization toolkit. That said, there are
> benefits to using {**plotly**}-based maps since the mapping APIs are
> very similar to the rest of {**plotly**}, and you can leverage larger
> {**plotly**} ecosystem (e.g., linking views client side … ). However,
> if you run into limitations with {**plotly**}’s mapping functionality,
> there is a very rich set of tools for interactive geospatial
> visualization in R, including but not limited to: {**leaflet**},
> {**mapview**}, {**mapedit**}, {**tmap**}, and {**mapdeck**} (Robin
> Lovelace 2019). Quoted from chapter 4 of [@sievert2019].

Another option to consider would be to use `ggplot2::geom_sf()` together
with 

-   `plotly::ggplotly()` or `Hmisc::ggpltlyr()` (Converts a `ggplot2::ggplot()` object to a {**plotly**} object, in {**Hmisc**} variant removes extraneous text that ggplotly() puts in hover text)
-   `ggiraph::geom_sf_interactive()` (Make 'ggplot2' Graphics Interactive)
-   {**ggspatial**} (Spatial Data Framework for 'ggplot2')
-   {**geofacet**} (‘ggplot2’ Faceting Utilities for Geographical Data)
This has the advantage that I am using with {**ggplot2**} known
territory. But in this chapter I will focus on {**leaflet**}.

:::::: my-resource
:::: my-resource-header
::: {#lem-042-leaflet}
: Leaflet resources on the Internet
:::
::::

::: my-resource-container
I am ignoring at the moment tutorials using Leaflet.js from scratch and
collect here only tutorial resources for the R {**leaflet**} package.
Many tutorials cover adding markers but my special is on `r glossary("choropleth")`
maps.

**Most important resources**

-   [An R Interface to Leaflet
    Maps](https://rstudio.github.io/leaflet/index.html): Official
    package documentation with a getting started page and several
    article covering a specific subject. I will start to learn the R
    leaflet package with this authoritative resource!
-   [Package
    {**leaflet**}](https://rstudio.r-universe.dev/leaflet/doc/manual.html):
    Official documentation in one page. Sorted not by function name but
    by short description. Helpful for looking up the name & syntax of a
    function for a specific problem. Last updated 2025-07-30.
-   [Leaflet.js](https://leafletjs.com/): Important for checking out the
    [API documentation of Leaflet](https://leafletjs.com/reference.html)
    occasionally when the meanings of certain parameters are not clear.
-   [Using arbitrary Leaflet JS plugins with Leaflet for
    R](https://gist.github.com/jcheng5/c084a59717f18e947a17955007dc5f92)
    by Joe Cheng
-   [Mapping
    applications](https://r.geocompx.org/adv-map#mapping-applications):
    Section of chapter 9 Making Maps with R of Geocomputation with R
    [@lovelace-2025].

**Educational Online Courses**

-   [Interactive Maps with leaflet in
    R](https://app.datacamp.com/learn/courses/interactive-maps-with-leaflet-in-r):
    datacamp course, updated August 2024.

**Additional resources**

-   [Mapping data in R](https://mapping-in-r.netlify.app/): Tutorial and
    [video](https://www.youtube.com/watch?v=w5U62wUki3E) by Lisa Lendway
    (Statistics and Data Science)
-   [Leaflet package in
    R](https://www.geeksforgeeks.org/r-language/leaflet-package-in-r/):
    geeksforgeeks, last updated 2025-07-23
-   [Interactive Maps with leaflet in
    R](https://r-graph-gallery.com/package/leaflet.html) and [Most basic
    background map with R and
    Leaflet](https://r-graph-gallery.com/179-show-a-map-with-leaflet-r.html):
    R Graph Gallery
-   [Interactive maps with leaflet in
    R](https://r-charts.com/spatial/interactive-maps-leaflet/): R Charts
-   [Leaflet](https://bookdown.org/nicohahn/making_maps_with_r5/docs/leaflet.html):
    Chapter of Making Maps with R [@hahn-2020]
-   [Interactive Maps with
    Leaflet](https://learn.r-journalism.com/en/mapping/leaflet_maps/leaflet/)
    and [Interactive Choropleth
    Maps](https://learn.r-journalism.com/en/mapping/census_maps/census-maps/):
    R for Journalists (includes for both part a video)
-   [Creating Interactive Spatial Maps in R Using
    Leaflet](https://earthdatascience.org/courses/earth-analytics/get-data-using-apis/leaflet-r/):
    Lesson 8 for the Earth Data Analytics Online Certificate by Earth
    Lab. [Data Scientist as
    Cartographer](https://library.virginia.edu/data/articles/data-scientist-as-cartographer-an-introduction-to-making-interactive-maps-in-r-with-leaflet):
    An Introduction to Making Interactive Maps in R with Leaflet by the
    Library of the University of Virgina. [An Introduction to R
    Leaflet](https://tomjenkins.netlify.app/tutorials/r-leaflet-introduction/):
    Tutorial by Tom Jenkins [Leaflet in
    R](https://www.jla-data.net/eng/leaflet-in-r-tips-and-tricks/) by
    Jindra Lacko.

**Videos**

-   [Mapping in R with
    leaflet](https://www.youtube.com/watch?v=w5U62wUki3E) by Lisa
    Lendway. It has also a supporting [lesson
    text](https://mapping-in-r.netlify.app/). 13:49 min
-   [How to FULLY Customize Leaflet Maps using R
    programming](https://www.youtube.com/watch?v=U0aJeaCnMeE) by Felix
    Analytix. 12:31 min
-   [Create an Interactive Leaflet Map in R
    Studio](https://www.youtube.com/watch?v=M2x4eLh1Ltk) by Madhuraj PK.
    8:07 min
-   [Introduction to Leaflet in R (R Tutorial For
    Beginners)](https://www.youtube.com/watch?v=F08PvG2c3P0) by
    GeoProgramming. 10:18 min
:::
::::::

::: {#imp-042-second-trial .callout-important}
##### This is already my second pass of the {**leaflet**} documentation

I have already previously worked on the {**leaflet**}
tutorials[^042-learn-leaflet-1].
:::

[^042-learn-leaflet-1]: I should get into the custom to document the
    writing dates for specific chapters. I have documented this now for this
    chapter directly unter the chapter heading.

## Getting started

### Basic usage

:::::: my-procedure
:::: my-procedure-header
::: {#prp-042-basicprocedure-leaflet}
: Four basic steps to produce a Leaflet map
:::
::::

::: my-procedure-container
1.  Create a map widget by calling `leaflet::leaflet()`.
2.  Add layers (i.e., features) to the map by using layer functions
    (e.g., `leaflet::addTiles()`, `leaflet::addMarkers()`,
    `leaflet::addPolygons()`) to modify the map widget.
3.  Repeat step 2 as desired.
4.  Print the map widget to display it.
:::
::::::

### Basic example

:::::: my-r-code
:::: my-r-code-header
::: {#cnj-042-basic-example}
: Basic R leaflet example
:::
::::

::: my-r-code-container
```{r}
#| label: fig-042-basic-example
#| lst-label: lst-042-basic-example
#| lst-cap: "Basic R leaflet example"
#| fig-cap: "A basic R leaflet example. Click at the marker to see what it indicates."


library(leaflet)

m <- leaflet() |>               # (1)  Create the ma widget  
  addTiles() |>                 # (2) Add default OpenStreetMap map tiles
    addMarkers(lng = 174.768,   # (3) Add another element to the map
               lat = -36.852,
               popup = "The birthplace of R")
m                               # (4) Print the map
```
:::
::::::

### Next step

The {**leaflet**} tutorial *highly* recommends to start with the article
[The Map Widget](https://rstudio.github.io/leaflet/articles/widget.html)
before exploring the rest of the site. It is the first article under the
menu "Articles". It seems to me that the best way to learn leaflet is to
proceed with the offered article in their sequence from top to the
bottom of the menu.

::: {#wrn-042-which-version .callout-warning}
##### {**leaflet**} Documentation refers to leaflet.js version 1.34

The links to the details leaflet.js documentation refers to the very old
[leaflet.js version
1.34](https://web.archive.org/web/20220512035219/https://leafletjs.com/reference-1.3.4.html)
only available through the internet archive. The current stable version
is [Leaflet 1.9.4](https://leafletjs.com/reference.html), and version
2.0 is already in preparation (see: [Leaflet
2.0.0-alpha](https://leafletjs.com/reference-2.0.0.html)).

Yesterday (August 16, 2025) the blog article [Leaflet 2.0 Alpha
released](https://leafletjs.com/2025/05/18/leaflet-2.0.0-alpha.html) has
been updated. It explains the new features in Leaflet.js 2.0. I assume
that in the near future the R {**leaflet**} package will be updated.

**Instead of the internet archive of the current offical documentation I
will use in this book to documentation of the current latest stable
version 1.9.4.**
:::

## The Map Widget

### Initializing options

The function `leaflet::leaflet()` returns a Leaflet map widget, which
stores a list of objects that can be modified or updated later. The map
widget can be initialized with certain parameters. This is achieved by
populating the options argument as in the following example.

```{r}
#| label: demo-leaflet-options
#| eval: false

# Set value for the minZoom and maxZoom settings.
leaflet(options = leafletOptions(minZoom = 0, maxZoom = 18))
```

The `leaflet::leafletOptions()` can be passed any option described in
the [leaflet reference
document](https://leafletjs.com/reference#map-option).

Using `leaflet::leafletOptions()`, you can set a custom
`r glossary("CRS")` and have your map displayed in a non spherical
`r glossary("Mercator-projection", "Mercator projection")` as described
in the article [Working with projections in
Leaflet](https://rstudio.github.io/leaflet/articles/projections.html).

### Map methods

You can manipulate the attributes of the map widget using a series of
methods.

`leaflet::setView()` sets the center of the map view and the zoom level;
`leaflet::fitBounds()` fits the view into the rectangle \[lng1, lat1\] –
\[lng2, lat2\]; `leaflet::clearBounds()` clears the bound, so that the
view will be automatically determined by the range of latitude/longitude
data in the map layers if provided.

For more detailed information see the help file [Methods to manipulate
the map
widget](https://rstudio.github.io/leaflet/reference/map-methods.html).
The help file also refers to a detailed table listing [Methods for
modifying map
state](https://leafletjs.com/reference#map-methods-for-modifying-map-state).

### The data object {#sec-042-data-object}

Both `leaflet::leaflet()` and the map layer functions have an optional
data parameter that is designed to receive spatial data in one of
several forms:

-   **From base R**:
    -   `lng`/`lat` matrix
    -   data frame with `lng`/`lat` columns
-   **From the {**maps**} package**:
    -   the data frame returned from `maps::map()`
-   **Simple features from the {**sf**} package**:

`leaflet::leaflet()` is, additionally, back-compatible with {**sp**}
SpatialDataFrames, although the use of these is
[discouraged](https://r-spatial.org/r/2023/04/10/evolution3.html) for
new users.

::: {#imp-042-use-data-object .callout-important}
The `data` argument is used to derive spatial data for functions that
need it; for example, if data is a {**sf**} Simple Features data.frame,
then calling `leaflet::addPolygons()` on that map widget will know to
add the polygons from the geometry column.
:::

For a normal matrix or data frame, any numeric column could potentially
contain spatial data. So we resort to guessing based on column names:

-   **latitude variable** is guessed by looking for columns named `lat`
    or `latitude` (case-insensitive)
-   **longitude variable** is guessed by looking for `lng`, `long`, or
    `longitude`

You can always explicitly identify latitude/longitude columns by
providing `lng` and `lat` arguments to the layer function.

A map layer may use a different data object to override the data
provided in `leaflet::leaflet()`.

:::::: my-r-code
:::: my-r-code-header
::: {#cnj-042-overriding-data-in-map-layer}
: Overriding data provided with `leaflet::leaflet()` in another layer
:::
::::

::: my-r-code-container
```{r}
#| label: fig-042-overriding-data
#| fig-cap: "The data from the first leaflet call was reversed by the second layer on the second leaflet call"
#| lst-label: lst-042-overriding-data
#| lst-cap: "Overriding data provided with `leaflet::leaflet()` in another layer" 
#| results: hold

df = data.frame(Lat = 1:10, Long = rnorm(10))
leaflet::leaflet()  |>  leaflet::addCircles(data = df)
glue::glue("------------------------------------------------------------------------")
leaflet::leaflet()  |>  leaflet::addCircles(data = df, lat = ~ Long, lng = ~ Lat)
```
:::
::::::

In the next code chunk I am not following the tutorial but will use my
own {**sf**} `r glossary("RWB")` dataset.

:::::: my-r-code
:::: my-r-code-header
::: {#cnj-042-rwb-leaflet-example}
: Using {sf} RWB dataset as my first leaflet example
:::
::::

::: my-r-code-container
```{r}
#| label: fig-042-rwb-my-first-leaflet-example
#| lst-label: lst-042-rwb-my-first-leaflet-example
#| fig-cap: "I succeeded with my first leaflet example using myRWB dataset. But the result is still ugly. I still have to learn about the many parameters to get better maps."
#| lst-cap: "Using {sf} RWB dataset as my first leaflet example"

rwb_map_2025 <- readRDS(paste0(here::here(), "/data/chap041/rwb_map_2025.rds"))


leaflet::leaflet() |> 
    leaflet::addPolygons(data = rwb_map_2025) |> 
    leaflet::addTiles(options = leaflet::tileOptions(noWrap = TRUE)) |> 
    leaflet::clearBounds()
```
:::
::::::

::: {#nte-042-rwb-my-first-leaflet-example .callout-note}
##### Evaluation of the result in @lst-042-rwb-my-first-leaflet-example

My first example worked. Although I have added two more lines than
necessary the result is still ugly. There are so many options I have
still to learn!
:::

### The Formula Interface

The arguments of all layer functions can take normal R objects, such as
a numeric vector for the `lat` argument, or a character vector of colors
for the `color` argument. They can also take a one-sided formula, in
which case the formula will be evaluated using the `data` argument as
the environment. For example, `~ x` means the variable `x` in the data
object, and you can write arbitrary expressions on the right-hand side,
e.g., `~ sqrt(x + 1)`.

:::::: my-r-code
:::: my-r-code-header
::: {#cnj-042-formula-interface}
: Formula Interface
:::
::::

::: my-r-code-container
```{r}
#| label: fig-042-formula-interface
#| fig-cap: "Arguments as R objects and the formula interface"
#| lst-label: lst-042-formula-interface
#| lst-cap: "Arguments as R objects and the formula interface"
#| results: hold
#| warning: false

# preventing message 'Assuming "lng" and "lat" are longitude and latitude, respectively'

df = data.frame(
  lat = rnorm(100),   
  lng = rnorm(100),  
  size = runif(100, 5, 20),
  color = sample(colors(), 100)
)

m = leaflet::leaflet(df)  |>  leaflet::addTiles()
m  |>  
    leaflet::addCircleMarkers(radius = ~size, color = ~color, fill = FALSE)
glue::glue("------------------------------------------------------------------------")
m  |>  
    leaflet::addCircleMarkers(radius = runif(100, 4, 10), color = c('red'))
```
:::
::::::

## Choropleths

The {**leaflet**} documentation transforms the [step-by-step
tutorial](https://leafletjs.com/examples/choropleth/) for leaflet.js
into R code.

### Data source

Instead of using the tutorial data I am working with my own RBW dataset.
`rbw_map_2925.rds` is a {**sf**} data frame suitable to work with
{**leaflet**} as I have already demonstrated with
@fig-042-rwb-my-first-leaflet-example.

### Basic world map

#### Choosing provider

For the basemap, the tutorial uses the same "mapbox.light" [MapBox](https://www.mapbox.com/) style
that the leaflet.js example does. This requires a MapBox account, that I
have already organized in a [previous learning activity on map
making](https://bookdown.org/pbaumgartner/geocomputing-notes/09-making-maps.html#mapdeck). 

During the registration process you get an access token that you have to put with a variable name into your `.Renviron` file. It is convention to use upper-case letter like `MAPBOX_ACCESS_TOKEN` or in my case `MAPBOX_PUBLIC_TOKEN` .

But one can also just use `leaflet::addTiles()` in place of the
`leaflet::addProviderTiles()` call, or [choose a free provider](https://leaflet-extras.github.io/leaflet-providers/preview/).

::: {.callout-note #nte-042-provider}
###### Adding tiles are for choropleth maps of {sf} data frames not necessary

Adding tiles in Leaflet refers to the process of overlaying a grid of small image tiles onto a map to create a background layer, which helps users orient themselves geographically.
In my understanding I do not need adding tiles as background layers as I am using just colors for the `r glossary("choropleth")` maps. All other necessary information like borders (`geometry` column) or country labels (`country_en` column) are stored in the {**sf**} class of data frame.
:::

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-042-most-basic-map}
: Most basic map from a {sf} data frame
::::::
:::
::::{.my-r-code-container}
```{r}
#| label: fig-042-most-basic-map
#| lst-label: lst-042-most-basic-map
#| fig-cap: "Basic map without adding tiles, created from {sf} data frame."
#| lst-cap: "Most basic map from a {sf} data frame"

rwb_map_2025 <- readRDS(paste0(here::here(), "/data/chap041/rwb_map_2025.rds"))

leaflet::leaflet(rwb_map_2025) |> 
  leaflet::addPolygons()
```

***

It is interesting that {**leaflet**} centered the map automatically. I do not know if this feature depends on the exclusion of `leaflet::setView()` and/or `leaflet::addTiles()`.
::::
:::::

But to learn how to apply `leaflet::addTiles()` I have used in the next code chunk [OpenTopoMap](https://leaflet-extras.github.io/leaflet-providers/preview/#filter=OpenTopoMap) from Google [OpenStreetMap](https://www.openstreetmap.org/).

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-042-opentopomap-tiles-demo}
: Demo: World map with freely available `OpenTopoMap` tiles from `OpenStreetMap`
::::::
:::
::::{.my-r-code-container}
```{r}
#| label: fig-042-opentopomap-tiles-demo
#| lst-label: lst-042-opentopomap-tiles-demo
#| fig-cap: "Demo: World map with freely available `OpenTopoMap` tiles from `OpenStreetMap`"
#| lst-cap: "Basic map adding OpenTopoMap tiles"

leaflet::leaflet(rwb_map_2025) |> 
  leaflet::setView(0, 45, 2) |>
  leaflet::addProviderTiles(
    "OpenTopoMap",
    options = leaflet::tileOptions(noWrap = TRUE)
    ) |> 
  leaflet::addPolygons()
```

***

(The line `options = leaflet::tileOptions(noWrap = TRUE)` is explained in @sec-042-bounding-box.)

Another --- even more basic option --- would be to use just `leaflet::addTiles()` instead of the line with `leaflet::addProviderTiles(<provider name>)`.
::::
:::::

In @cnj-042-opentopomap-tiles-demo I have used `specific leaflet::setView()` in anticipation of appropriate arguments to center the map explained in the folowing section on 'Area selection'.

#### Area selection

The next problem for a nice choropleth map is to get the latitude and longitude data for an appropriate area selection fitting in the plotting bounding box. As I am
using a world map I could try without these data, but it turned in
@fig-042-rwb-my-first-leaflet-example out, that this is not a correct solution.

To get exact coordinates for **any** map I learned from [another previous learning enterprise](https://bookdown.org/pbaumgartner/gdswr-notes-new/91-creating-maps.html#zooming-into-a-specific-area) following an article and video by FelixAnalytix [-@felixanalytix-2023; -@felixanalytix-2023a] that  [OpenStreetMap](https://www.openstreetmap.org/) has a [nice tool](https://www.openstreetmap.org/export) to get the coordinates of a specific bounding box.

There are several options to get the coordinates of the bounding box for Leaflet.

##### Center coordinates

(The next two paragraphs originate from the Brave-KI with the search string "r leaflet latitude and longitude for world center point".)

> The geographic center of the world is not a single, universally agreed-upon point, but a commonly referenced location is the intersection of the Prime Meridian (0° longitude) and the Equator (0° latitude), which is located in the Gulf of Guinea, off the western coast of Africa  This point is often used as a reference for the world's center in geographic and cartographic contexts.

> In the R programming language, when using the {**leaflet**} package, the `leaflet::setView()` function is used to center the map on a specific location by specifying the longitude and latitude. For the world center point, this would be set to longitude 0 and latitude 0. The {**leaflet**} package expects all point, line, and shape data to be specified in latitude and longitude using the WGS 84 coordinate reference system (EPSG:4326)  For example, to center a map on the world's center point, you would use `leaflet::setView(lng = 0, lat = 0, zoom = 2)` within a `leaflet::leaflet()` object.

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-042-world-map-centered-coordinates}
: World map with centered `0` coordinates
::::::
:::
::::{.my-r-code-container}
```{r}
#| label: fig-042-world-map-centered-coordinates
#| lst-label: lst-042-world-map-centered-coordinates
#| lst-cap: "World map with centered `0` coordinates using MapBox tiles"
#| fig-cap: "In my standard plotting configuration a world map with lng = 0 and lat = 0 is not correctly centered."

leaflet::leaflet(rwb_map_2025) |> 
  leaflet::setView(0, 0, 2) |> 
  leaflet::addProviderTiles(
      "MapBox", 
      options = leaflet::providerTileOptions(
            id = "mapbox.light",
            accessToken = Sys.getenv('MAPBOX_ACCESS_TOKEN')
            )
    ) |> 
    leaflet::addPolygons()
```

::::
:::::

::: {.callout-important #imp-042-world-center-point}
As I have already noticed in the [World tab of the Basic Map section](https://bookdown.org/pbaumgartner/geocomputing-notes/97-learn-leaflet.html#basic-map), because of the height-width ratio a small correction of the north/south center point is necessary.

Although my RWB map does not contain Antarctica, the map is still too big. Previously (see [World tab of the Basic Map section](https://bookdown.org/pbaumgartner/geocomputing-notes/97-learn-leaflet.html#basic-map)) I believed that it is just a mater of the heigt-width ratio of the figure. But now I think the situation is more complex:

Finding the best configuration to fit my plotting area depends on several interacting parameters: 

- `lat` and `lng` coordinates, 
- zoom level, 
- width and height of the figure 
- aspect ration and the 
- layout (space) provided by Quarto

Another important issue affecting the center coordinates is the omission of Antarctica in my world map!
:::

As in @imp-042-world-center-point explained, it is difficult to understand the result of the different interacting factors. Therefore a bit of experimentation is always necessary.


::: {.column-page-inset}


:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-042-practical-center-coordinates}
: World map with theoretical and practical center coordinates
::::::
:::
::::{.my-r-code-container}
```{r}
#| label: fig-042-practical-center-coordinates
#| lst-label: lst-042-practical-center-coordinates
#| fig-cap: "World map centered after some experimentation with figure dimension, coordinates and Quarto layout. The markers show the difference between theoretical (0, 0) and practical (0, 45) center coordinates."
#| lst-cap: "World map centered after some experimentation showing theoretical (0, 0) and practical (0, 45) center coordinates"
#| fig-height: 8
#| fig-width: 7
#| echo: fenced

leaflet::leaflet(rwb_map_2025) |> 
  leaflet::setView(0, 45, 2) |>
  leaflet::addPolygons() |> 
  leaflet::addMarkers(0, 0, popup = 'Theretical center at 0,0') |> 
  leaflet::addMarkers(0, 45, popup = 'Practical center at 0,45')
```

::::
:::::

::: 

#### Leaflet bounding box for a world map {#sec-042-bounding-box}

(The next two paragraphs originate from the Brave-KI with the search string "r leaflet bounding box for a world map".)

> A function can be created to calculate the bounding box based on the map's center coordinates, zoom level, and the specified width and height of the map widget. This approach uses the formulae derived from Leaflet's tile grid system, where the longitude width is calculated as 

$$360 \times \text{width} / 2^{(\text{zoom} + 8)}$$ 

and the latitude height as 

$$360 \times \text{height} \times \cos(\text{lat}/180 \times \pi) / 2^{(\text{zoom} + 8)}$$  

> The bounding box coordinates are then derived from the center point and these calculated extents  This method is effective for maps with defined dimensions and a known zoom level, though accuracy can decrease at lower zoom levels. 

> The maximum bounds for the entire world in Leaflet are defined by the coordinates $[-90, -180]$
(southwest corner) and $[90, 180]$ (northeast corner), which represent the full range of latitude and longitude.  To ensure the map displays only one instance of the world and prevents the display of duplicate world copies when panning, the `noWrap` option should be set to `true` when adding a tile layer, as I have done in @lst-042-rwb-my-first-leaflet-example.

I haven't tested the pretty complicated calculation for the bounding box coordinates. It is easier to use the defined coordinates together with the `noWrap` option already used in @lst-042-opentopomap-tiles-demo.

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-042-bounding-box}
: World map with bounding box
::::::
:::
::::{.my-r-code-container}
```{r}
#| label: fig-042-bounding-box
#| lst-label: lst-042-bounding-box
#| fig-cap: "Demo: World map with freely available `OpenTopoMap` tiles from `OpenStreetMap`"
#| lst-cap: "Basic map adding OpenTopoMap tiles"

leaflet::leaflet(rwb_map_2025) |> 
  leaflet::setMaxBounds(-90, -180, 90, 180) |>
  leaflet::addProviderTiles(
    "OpenTopoMap",
    options = leaflet::tileOptions(noWrap = TRUE)
    ) |>
  leaflet::addPolygons()
```


::::
:::::

#### Selecting a bounding area manually

Another strategy is to set the bounding box in OpenStreetMap manually as the following image shows:

![Selecting in OpenStreetMap a bounding area manually](img/openstreetmap-bounding-box-world-min.png){#fig-042-openstreetmap
fig-alt="alt-text" fig-align="center" 
width="100%"}

I have set the bounding area for a world map without Antarctica. I used the mouse to get the appropriate window on the right pane. The coordinates appear on the left side. The coordinates -59.9 / -168.8 (bottom, left) represent `lat` and `lng` of the bottom left point. 85.0 / -168.8 (top, right) are the coordinates for the top right point.

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-042-bounding-area-manually}
: Setting the bounding area manually with OpenStreetMap tool
::::::
:::
::::{.my-r-code-container}
```{r}
#| label: fig-042-bounding-area-manually
#| lst-label: lst-042-bounding-area-manually
#| fig-cap: "World map with bounding area set manually"
#| lst-cap: "World map with bounding area set manually"

leaflet::leaflet(rwb_map_2025) |> 
  leaflet::setMaxBounds(-60, -170, 85, 170) |>
  leaflet::addProviderTiles(
    "OpenTopoMap",
    options = leaflet::tileOptions(noWrap = TRUE)
    ) |>
  leaflet::addPolygons()
```

::::
:::::

The results from @lst-042-bounding-area-manually and @lst-042-bounding-box are very similar as their values differ only few degrees. From the practical perspective to choose any region of the world only the last option (setting the boundaries manually) is viable.

## Adding some color

Until now we have only use the default styling options for `leaflet::addPolygons()`. It resulted in dark blue thick country border lines and light blue background for the country areas.

An important part of spatial visualization is mapping variables to colors. While R has no shortage of built-in functionality to map values to colors, the {**leaflet**} developers found that there was enough friction in the process to warrant introducing some wrapper functions that do a lot of the work for you.

To that end, they’ve created a family of `color*()` convenience functions that can be used to easily generate palette functions. Essentially, you call the appropriate color function with 

1) the colors you want to use and 
2) optionally, the range of inputs (i.e., *domain*) that are expected. 

The color function returns a palette function that can be passed a vector of input values, and it’ll return a vector of colors in `#RRGGBB(AA)` format.

There are currently three color functions for dealing with continuous input: `leaflet::colorNumeric()`, `leaflet::colorBin()`, and `leaflet::colorQuantile()`; and one for categorical input, `leaflet::colorFactor()`.

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-042-color-numeric-example}
: Using `leaflet::colorNumeric()` to demonstrate the function results
::::::
:::
::::{.my-r-code-container}
```{r}
#| label: 042-color-numeric-example
#| lst-label: lst-042-color-numeric-example
#| lst-cap: "Demonstration of the effects of `leaflet::colorNumeric()`"

# Call the color function (colorNumeric) to create a new palette function
pal <- leaflet::colorNumeric(c("red", "green", "blue"), 1:100)

# Pass the palette function a data vector to get the corresponding colors
pal(c(1, 6, 9, 20, 25, 29, 30, 31, 40, 45, 60, 90, 100))
```

::::
:::::

To understand the effect of the code in @lst-042-color-numeric-example it is helpful to convert the resulting vector of colors from `#RRGGBB(AA)` format to the colors themselves:

![Demonstration of the numeric leaflet color function](img/colorNumeric-examples-min.png){#fig-041-042-color-numeric-example 
fig-alt="alt-text" fig-align="center" width="100%"}

The three palette colors (red, green, blue) are equally spaced through the domain (1 to 100). Depending of the actual data value, pal interpolates the values and spits out the appropriate color for this value. For instance in the example the range between red and green is 50, half of it (25) is a mixture between red and green. Low values are different shades of red, values started from the middle value 25 gets with their rising number greener until the reach the 50. From here the blue color wins increasing effect.


The four color functions all have two required arguments, `palette` and `domain`.

**The palette argument** specifies the colors to map the data to. This argument can take one of several forms:

- The name of a preset palette from the {**RColorBrewer**} package, e.g., "RdYlBu", "Accent", or "Greens".
- The full name of the colorblind-friendly {**viridis**} palette: "magma", "inferno", "plasma", "viridis", "cividis", "rocket", "mako", or "turbo".
- A character vector of RGB or named colors, e.g., `grDevices::palette()`, `c("#000000", "#0000FF", "#FFFFFF")`, `grDevices::topo.colors(10)`.
- A function that receives a single value between 0 and 1 and returns a color, e.g.,: `grDevices::colorRamp(c("#000000", "#FFFFFF"), interpolate="spline")`

**The domain argument** tells the color function the range of input values. You can pass `NULL` here to create a palette function that doesn’t have a preset range; the range will be inferred from the data each time you invoke the palette function. If you use a palette function multiple times across different data, it’s important to provide a non-`NULL` value for `domain` so the scaling between data and colors is consistent.

### Coloring continuous data

#### Continuous colors

The following graphics uses continuous colors to map continuous input. We will map the {**sf**} data frame `rwb_map_20225` with its global score values of the `r glossary("WPFI")` directly to the "Blues" palette from [Color Brewer 2](https://colorbrewer2.org/#type=sequential&scheme=Blues&n=9). The "Blues" palette only contains nine colors, but `leaflet::colorNumeric()` interpolates these colors so we get continuous output.

(1) The **palette parameter** is the ordered list of colors you will map colors to. In this case we used a Color Brewer palette, but we could’ve used `c("white", "navy")` or `c("#FFFFFF", "#000080")` for a similar effect. You can also pass more than two colors, for a diverging palette for example. And for maximum flexibility, you can even pass a function that takes a numeric value over the interval [0,1] and returns a color.
(2) The **domain parameter** indicates the set of input values that we are mapping to these colors. For `leaflet::colorNumeric()`, you can provide either the full range of the data, a min/max value (11.32 / 92.31) as in this example, or a set of numbers that `leaflet::colorNumeric()` can call `range()` on.
(3) The result is **pal()**, a function that can accept numeric vectors with values in the range `range(countries$gdp_md_est)` and return colors in `"#RRGGBB"` format.



::: {.column-page-inset}

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-042-continuous-colors}
: Choropleth map with continuous colors for 2025 WPF Index
::::::
:::
::::{.my-r-code-container}
```{r}
#| label: fig-042-continuous-colors
#| lst-label: lst-042-continuous-colors
#| fig-cap: "Choropleth map with continuous colors for the global score 2025 of the World Press Freedom Index"
#| lst-cap: "Choropleth map with continuous colors for the WPFI 2025"
#| fig-height: 8
#| fig-width: 7

rwb_map_2025 <- readRDS(paste0(here::here(), "/data/chap041/rwb_map_2025.rds"))

# Create a continuous palette function
pal <- leaflet::colorNumeric(      # (3)
  palette = "Blues",               # (1)
  domain = rwb_map_2025$score)     # (2)

leaflet::leaflet(rwb_map_2025) |> 
  leaflet::setView(0, 45, 2) |>
  leaflet::addPolygons(
    stroke = FALSE, 
    smoothFactor = 0.2, 
    fillOpacity = 1,
    color = ~pal(score)
  )
```

::::
:::::

::: 

Compare @fig-041-plot-map-draft1-2025 with @fig-042-continuous-colors. Keep in mind that @fig-042-continuous-colors 

- does not have a `r glossary("CRS")` 
- does not use country border lines and 
- uses a bigger Quarto layout. 

But besides these differences both figures are quite similar.

#### Discrete colors

Continuous input is mapped onto discrete colors with `leaflet::colorBin()` and `leaflet::colorQuantile()`.

**`leaflet::colorBin()`** maps numeric input data to a fixed number of output colors using binning (slicing the input domain up by value).

You can specify either the exact breaks to use, or the desired number of bins. Note that in the latter case, if `pretty = TRUE` (the default) you’ll end up with nice round breaks but not necessarily the number of bins you wanted.

::: {.column-page-inset}

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-042-colors-binned}
: Choropleth map with discrete colors for 2025 WPF Index
::::::
:::
::::{.my-r-code-container}
```{r}
#| label: fig-042-colors-binned
#| lst-label: lst-042-colors-binned
#| fig-cap: "Choropleth map with fixed number of colors for the global score 2025 of the World Press Freedom Index"
#| lst-cap: "Choropleth map with discrete colors for the WPFI 2025"
#| fig-height: 8
#| fig-width: 7

rwb_map_2025 <- readRDS(paste0(here::here(), "/data/chap041/rwb_map_2025.rds"))

labels <- sprintf(
  "<strong>%s</strong><br/>score: %g",
  rwb_map_2025$country_en, rwb_map_2025$score
) |>  lapply(htmltools::HTML)

# Create a discrete palette function

binpal <- leaflet::colorBin(
  palette = "Blues", 
  domain = rwb_map_2025$score, 
  bins = 9, 
  pretty = FALSE)

leaflet::leaflet(rwb_map_2025) |> 
  leaflet::setView(0, 45, 2) |>
  leaflet::addPolygons(
    stroke = FALSE, 
    smoothFactor = 0.5, 
    fillOpacity = 1,
    color = ~binpal(score),
    label = labels
  ) 
```

::::
:::::
::: 

## Glossary Entries {.unnumbered}

```{r}
#| label: glossary-table
#| echo: false

glossary_table()
```

------------------------------------------------------------------------

## Session Info {.unnumbered}

::::: my-r-code
::: my-r-code-header
Session Info
:::

::: my-r-code-container
```{r}
#| label: session-info

sessioninfo::session_info()
```
:::
:::::
