# Learn Leaflet {#sec-chap042}

August 17-21, 2025

```{r}
#| label: setup
#| results: hold
#| include: false

base::source(file = "R/helper.R")

```

:::::: {#obj-chap100}
::::: my-objectives
::: my-objectives-header
Objectives
:::

::: my-objectives-container
Learn using {**leaflet**} / leaflet.js using my RWB data as practical
example
:::
:::::
::::::

## Preliminary remark

After following [Making maps with R](https://r.geocompx.org/adv-map)
(chapter 9 of the online book [Geocomputation with
R](https://r.geocompx.org/)) it turned out in my @sec-chap041 that
[{**leaflet**}](https://rstudio.github.io/leaflet/index.html) /
[leaflet.js](https://leafletjs.com/) is the most mature and widely used
interactive mapping package in R interactive map drawing software.
{**leaflet**} has twice more downloads than {**tmap**} which is as the
moment the leading spatial geographic map tool. (See
@lst-042-mapping-packages-downloads which contains a list of downloads
for several map drawing packages.)

::: {#nte-042-new-map-package-maps .callout-note}
##### Added {**maps**} to @lst-042-mapping-packages-downloads

I just learned in the section @sec-042-data-object that {**maps**} is
another important package ranking with it download numbers in the second
place!

I added this package therefore to @lst-042-mapping-packages-downloads.
The above paragraph is not correct anymore as {**maps**} has about 50%
more downloads than {**leaflet**}.
:::

:::::: my-r-code
:::: my-r-code-header
::: {#cnj-042-mapping-packages-downloads}
: Overview of download numbers of map packages
:::
::::

::: my-r-code-container
```{r}
#| label: mapping-packages-downloads
#| lst-label: lst-042-mapping-packages-downloads
#| lst-cap: Overview of download numbers of map packages

my_pkgs_dl(
  pkgs = c(
    "tmap", 
    "plotly", 
    "mapview",
    "mapdeck",
    "googleway",
    "mapsf",
    "mapmisc",
    "leaflet",
    "Rgooglemaps",
    "ggmap",
    "mapedit",
    "ggiraph",
    "maps"
    ),
  period = "last-month", 
  days = 30
)
```
:::
::::::

Although {**leaflet**} has with about 3.000 downloads/day only about the
half of the {**plotly**} downloads it is a specialized map drawing
software whereas {**plotly**} is a general interactive web graphics
tool.

> It’s worth noting that {**plotly**} aims to be a general purpose
> visualization library, and thus, doesn’t aim to be the most fully
> featured geo-spatial visualization toolkit. That said, there are
> benefits to using {**plotly**}-based maps since the mapping APIs are
> very similar to the rest of {**plotly**}, and you can leverage larger
> {**plotly**} ecosystem (e.g., linking views client side … ). However,
> if you run into limitations with {**plotly**}’s mapping functionality,
> there is a very rich set of tools for interactive geospatial
> visualization in R, including but not limited to: {**leaflet**},
> {**mapview**}, {**mapedit**}, {**tmap**}, and {**mapdeck**} (Robin
> Lovelace 2019). Quoted from chapter 4 of [@sievert2019].

Another option to consider would be to use `ggplot2::geom_sf()` together
with

-   `plotly::ggplotly()` or `Hmisc::ggpltlyr()` (Converts a
    `ggplot2::ggplot()` object to a {**plotly**} object, in {**Hmisc**}
    variant removes extraneous text that ggplotly() puts in hover text)
-   `ggiraph::geom_sf_interactive()` (Make 'ggplot2' Graphics
    Interactive)
-   {**ggspatial**} (Spatial Data Framework for 'ggplot2')
-   {**geofacet**} (‘ggplot2’ Faceting Utilities for Geographical Data)
    This has the advantage that I am using with {**ggplot2**} known
    territory. But in this chapter I will focus on {**leaflet**}.

:::::: my-resource
:::: my-resource-header
::: {#lem-042-leaflet}
: Leaflet resources on the Internet
:::
::::

::: my-resource-container
I am ignoring to list tutorials using Leaflet.js from scratch and
collect here only resources for learning the R {**leaflet**} package.
Many tutorials cover some special actions like adding markers but my
special focus at the moment is on `r glossary("choropleth")` maps.

**Most important resources**

-   [An R Interface to Leaflet
    Maps](https://rstudio.github.io/leaflet/index.html): Official
    package documentation with a getting started page and several
    article covering a specific subject. I will start to learn the R
    leaflet package with this authoritative resource!
-   [Package
    {**leaflet**}](https://rstudio.r-universe.dev/leaflet/doc/manual.html):
    Official documentation in one page. Sorted not by function name but
    by short description. Helpful for looking up the name & syntax of a
    function for a specific problem. Last updated 2025-07-30.
-   [Leaflet.js](https://leafletjs.com/): Important for checking out the
    [API documentation of Leaflet](https://leafletjs.com/reference.html)
    occasionally when the meanings of certain parameters are not clear.
-   [Using arbitrary Leaflet JS plugins with Leaflet for
    R](https://gist.github.com/jcheng5/c084a59717f18e947a17955007dc5f92)
    by Joe Cheng
-   [Mapping
    applications](https://r.geocompx.org/adv-map#mapping-applications):
    Section of chapter 9 Making Maps with R of Geocomputation with R
    [@lovelace-2025].

**Educational Online Courses**

-   [Interactive Maps with leaflet in
    R](https://app.datacamp.com/learn/courses/interactive-maps-with-leaflet-in-r):
    datacamp course, updated August 2024.

**Additional resources**

-   [Mapping data in R](https://mapping-in-r.netlify.app/): Tutorial and
    [video](https://www.youtube.com/watch?v=w5U62wUki3E) by Lisa Lendway
    (Statistics and Data Science)
-   [Leaflet package in
    R](https://www.geeksforgeeks.org/r-language/leaflet-package-in-r/):
    geeksforgeeks, last updated 2025-07-23
-   [Interactive Maps with leaflet in
    R](https://r-graph-gallery.com/package/leaflet.html) and [Most basic
    background map with R and
    Leaflet](https://r-graph-gallery.com/179-show-a-map-with-leaflet-r.html):
    R Graph Gallery
-   [Interactive maps with leaflet in
    R](https://r-charts.com/spatial/interactive-maps-leaflet/): R Charts
-   [Leaflet](https://bookdown.org/nicohahn/making_maps_with_r5/docs/leaflet.html):
    Chapter of Making Maps with R [@hahn-2020]
-   [Interactive Maps with
    Leaflet](https://learn.r-journalism.com/en/mapping/leaflet_maps/leaflet/)
    and [Interactive Choropleth
    Maps](https://learn.r-journalism.com/en/mapping/census_maps/census-maps/):
    R for Journalists (includes for both part a video)
-   [Creating Interactive Spatial Maps in R Using
    Leaflet](https://earthdatascience.org/courses/earth-analytics/get-data-using-apis/leaflet-r/):
    Lesson 8 for the Earth Data Analytics Online Certificate by Earth
    Lab. [Data Scientist as
    Cartographer](https://library.virginia.edu/data/articles/data-scientist-as-cartographer-an-introduction-to-making-interactive-maps-in-r-with-leaflet):
    An Introduction to Making Interactive Maps in R with Leaflet by the
    Library of the University of Virgina. [An Introduction to R
    Leaflet](https://tomjenkins.netlify.app/tutorials/r-leaflet-introduction/):
    Tutorial by Tom Jenkins [Leaflet in
    R](https://www.jla-data.net/eng/leaflet-in-r-tips-and-tricks/) by
    Jindra Lacko.

**Videos**

-   [Mapping in R with
    leaflet](https://www.youtube.com/watch?v=w5U62wUki3E) by Lisa
    Lendway. It has also a supporting [lesson
    text](https://mapping-in-r.netlify.app/). 13:49 min
-   [How to FULLY Customize Leaflet Maps using R
    programming](https://www.youtube.com/watch?v=U0aJeaCnMeE) by Felix
    Analytix. 12:31 min
-   [Create an Interactive Leaflet Map in R
    Studio](https://www.youtube.com/watch?v=M2x4eLh1Ltk) by Madhuraj PK.
    8:07 min
-   [Introduction to Leaflet in R (R Tutorial For
    Beginners)](https://www.youtube.com/watch?v=F08PvG2c3P0) by
    GeoProgramming. 10:18 min
:::
::::::

::: {#imp-042-second-trial .callout-important}
##### This is already my second pass of the {**leaflet**} documentation

I have already previously worked on the {**leaflet**}
tutorials[^042-learn-leaflet-1].
:::

[^042-learn-leaflet-1]: I should get into the custom to document the
    writing dates for specific chapters. I have documented this now for
    this chapter directly unter the chapter heading.

## Getting started

### Basic usage

:::::: my-procedure
:::: my-procedure-header
::: {#prp-042-basicprocedure-leaflet}
: Four basic steps to produce a Leaflet map
:::
::::

::: my-procedure-container
1.  Create a map widget by calling `leaflet::leaflet()`.
2.  Add layers (i.e., features) to the map by using layer functions
    (e.g., `leaflet::addTiles()`, `leaflet::addMarkers()`,
    `leaflet::addPolygons()`) to modify the map widget.
3.  Repeat step 2 as desired.
4.  Print the map widget to display it.
:::
::::::

### Basic example

:::::: my-r-code
:::: my-r-code-header
::: {#cnj-042-basic-example}
: Basic R leaflet example
:::
::::

::: my-r-code-container
```{r}
#| label: fig-042-basic-example
#| lst-label: lst-042-basic-example
#| lst-cap: "Basic R leaflet example"
#| fig-cap: "A basic R leaflet example. Click at the marker to see what it indicates."


library(leaflet)

m <- leaflet() |>               # (1)  Create the ma widget  
  addTiles() |>                 # (2) Add default OpenStreetMap map tiles
    addMarkers(lng = 174.768,   # (3) Add another element to the map
               lat = -36.852,
               popup = "The birthplace of R")
m                               # (4) Print the map
```
:::
::::::

### Next step

The {**leaflet**} tutorial *highly* recommends to start with the article
[The Map Widget](https://rstudio.github.io/leaflet/articles/widget.html)
before exploring the rest of the site. It is the first article under the
menu "Articles". It seems to me that the best way to learn leaflet is to
proceed with the offered article in their sequence from top to the
bottom of the menu.

::: {#wrn-042-which-version .callout-warning}
##### {**leaflet**} Documentation refers to leaflet.js version 1.34

The links to the details leaflet.js documentation refers to the very old
[leaflet.js version
1.34](https://web.archive.org/web/20220512035219/https://leafletjs.com/reference-1.3.4.html)
only available through the internet archive. The current stable version
is [Leaflet 1.9.4](https://leafletjs.com/reference.html), and version
2.0 is already in preparation (see: [Leaflet
2.0.0-alpha](https://leafletjs.com/reference-2.0.0.html)).

Yesterday (August 16, 2025) the blog article [Leaflet 2.0 Alpha
released](https://leafletjs.com/2025/05/18/leaflet-2.0.0-alpha.html) has
been updated. It explains the new features in Leaflet.js 2.0. I assume
that in the near future the R {**leaflet**} package will be updated.

**Instead of the internet archive of the current offical documentation I
will use in this book to documentation of the current latest stable
version 1.9.4.**
:::

## The Map Widget

### Initializing options

The function `leaflet::leaflet()` returns a Leaflet map widget, which
stores a list of objects that can be modified or updated later. The map
widget can be initialized with certain parameters. This is achieved by
populating the options argument as in the following example.

```{r}
#| label: demo-leaflet-options
#| eval: false

# Set value for the minZoom and maxZoom settings.
leaflet(options = leafletOptions(minZoom = 0, maxZoom = 18))
```

The `leaflet::leafletOptions()` can be passed any option described in
the [leaflet reference
document](https://leafletjs.com/reference#map-option).

Using `leaflet::leafletOptions()`, you can set a custom
`r glossary("CRS")` and have your map displayed in a non spherical
`r glossary("Mercator-projection", "Mercator projection")` as described
in the article [Working with projections in
Leaflet](https://rstudio.github.io/leaflet/articles/projections.html).

### Map methods

You can manipulate the attributes of the map widget using a series of
methods.

`leaflet::setView()` sets the center of the map view and the zoom level;
`leaflet::fitBounds()` fits the view into the rectangle \[lng1, lat1\] –
\[lng2, lat2\]; `leaflet::clearBounds()` clears the bound, so that the
view will be automatically determined by the range of latitude/longitude
data in the map layers if provided.

For more detailed information see the help file [Methods to manipulate
the map
widget](https://rstudio.github.io/leaflet/reference/map-methods.html).
The help file also refers to a detailed table listing [Methods for
modifying map
state](https://leafletjs.com/reference#map-methods-for-modifying-map-state).

### The data object {#sec-042-data-object}

Both `leaflet::leaflet()` and the map layer functions have an optional
data parameter that is designed to receive spatial data in one of
several forms:

-   **From base R**:
    -   `lng`/`lat` matrix
    -   data frame with `lng`/`lat` columns
-   **From the {**maps**} package**:
    -   the data frame returned from `maps::map()`
-   **Simple features from the {**sf**} package**:

`leaflet::leaflet()` is, additionally, back-compatible with {**sp**}
SpatialDataFrames, although the use of these is
[discouraged](https://r-spatial.org/r/2023/04/10/evolution3.html) for
new users.

::: {#imp-042-use-data-object .callout-important}
The `data` argument is used to derive spatial data for functions that
need it; for example, if data is a {**sf**} Simple Features data.frame,
then calling `leaflet::addPolygons()` on that map widget will know to
add the polygons from the geometry column.
:::

For a normal matrix or data frame, any numeric column could potentially
contain spatial data. So we resort to guessing based on column names:

-   **latitude variable** is guessed by looking for columns named `lat`
    or `latitude` (case-insensitive)
-   **longitude variable** is guessed by looking for `lng`, `long`, or
    `longitude`

You can always explicitly identify latitude/longitude columns by
providing `lng` and `lat` arguments to the layer function.

A map layer may use a different data object to override the data
provided in `leaflet::leaflet()`.

:::::: my-r-code
:::: my-r-code-header
::: {#cnj-042-overriding-data-in-map-layer}
: Overriding data provided with `leaflet::leaflet()` in another layer
:::
::::

::: my-r-code-container
```{r}
#| label: fig-042-overriding-data
#| fig-cap: "The data from the first leaflet call was reversed by the second layer on the second leaflet call"
#| lst-label: lst-042-overriding-data
#| lst-cap: "Overriding data provided with `leaflet::leaflet()` in another layer" 
#| results: hold

df = data.frame(Lat = 1:10, Long = rnorm(10))
leaflet::leaflet()  |>  leaflet::addCircles(data = df)
glue::glue("------------------------------------------------------------------------")
leaflet::leaflet()  |>  leaflet::addCircles(data = df, lat = ~ Long, lng = ~ Lat)
```
:::
::::::

In the next code chunk I am not following the tutorial but will use my
own {**sf**} `r glossary("RWB")` dataset.

:::::: my-r-code
:::: my-r-code-header
::: {#cnj-042-rwb-leaflet-example}
: Using {sf} RWB dataset as my first leaflet example
:::
::::

::: my-r-code-container
```{r}
#| label: fig-042-rwb-my-first-leaflet-example
#| lst-label: lst-042-rwb-my-first-leaflet-example
#| fig-cap: "I succeeded with my first leaflet example using myRWB dataset. But the result is still ugly. I still have to learn about the many parameters to get better maps."
#| lst-cap: "Using {sf} RWB dataset as my first leaflet example"

rwb_map_2025 <- readRDS(paste0(here::here(), "/data/chap041/rwb_map_2025.rds"))


leaflet::leaflet() |> 
    leaflet::addPolygons(data = rwb_map_2025) |> 
    leaflet::addTiles(options = leaflet::tileOptions(noWrap = TRUE)) |> 
    leaflet::clearBounds()
```
:::
::::::

::: {#nte-042-rwb-my-first-leaflet-example .callout-note}
##### Evaluation of the result in @lst-042-rwb-my-first-leaflet-example

My first example worked. Although I have added two more lines than
necessary the result is still ugly. There are so many options I have
still to learn!
:::

### The Formula Interface

The arguments of all layer functions can take normal R objects, such as
a numeric vector for the `lat` argument, or a character vector of colors
for the `color` argument. They can also take a one-sided formula, in
which case the formula will be evaluated using the `data` argument as
the environment. For example, `~ x` means the variable `x` in the data
object, and you can write arbitrary expressions on the right-hand side,
e.g., `~ sqrt(x + 1)`.

:::::: my-r-code
:::: my-r-code-header
::: {#cnj-042-formula-interface}
: Formula Interface
:::
::::

::: my-r-code-container
```{r}
#| label: fig-042-formula-interface
#| fig-cap: "Arguments as R objects and the formula interface"
#| lst-label: lst-042-formula-interface
#| lst-cap: "Arguments as R objects and the formula interface"
#| results: hold
#| warning: false

# preventing message 'Assuming "lng" and "lat" are longitude and latitude, respectively'

df = data.frame(
  lat = rnorm(100),   
  lng = rnorm(100),  
  size = runif(100, 5, 20),
  color = sample(colors(), 100)
)

m = leaflet::leaflet(df)  |>  leaflet::addTiles()
m  |>  
    leaflet::addCircleMarkers(radius = ~size, color = ~color, fill = FALSE)
glue::glue("------------------------------------------------------------------------")
m  |>  
    leaflet::addCircleMarkers(radius = runif(100, 4, 10), color = c('red'))
```
:::
::::::

## Choropleths

The {**leaflet**} documentation transforms the [step-by-step
tutorial](https://leafletjs.com/examples/choropleth/) for leaflet.js
into R code.

### Data source

Instead of using the tutorial data I am working with my own RBW dataset.
`rbw_map_2925.rds` is a {**sf**} data frame suitable to work with
{**leaflet**} as I have already demonstrated with
@fig-042-rwb-my-first-leaflet-example.

### Basic world map

#### Choosing provider

For the basemap, the tutorial uses the same "mapbox.light"
[MapBox](https://www.mapbox.com/) style that the leaflet.js example
does. This requires a MapBox account, that I have already organized in a
[previous learning activity on map
making](https://bookdown.org/pbaumgartner/geocomputing-notes/09-making-maps.html#mapdeck).

During the registration process you get an access token that you have to
put with a variable name into your `.Renviron` file. It is convention to
use upper-case letter like `MAPBOX_ACCESS_TOKEN`.

But one can also just use `leaflet::addTiles()` in place of the
`leaflet::addProviderTiles()` call, or [choose a free
provider](https://leaflet-extras.github.io/leaflet-providers/preview/).

::: {#nte-042-provider .callout-note}
###### Adding tiles are for choropleth maps of {sf} data frames not necessary

Adding tiles in Leaflet refers to the process of overlaying a grid of
small image tiles onto a map to create a background layer, which helps
users orient themselves geographically. In my understanding I do not
need adding tiles as background layers as I am using just colors for the
`r glossary("choropleth")` maps. All other necessary information like
borders (`geometry` column) or country labels (`country_en` column) are
stored in the {**sf**} class of data frame.
:::

:::::: my-r-code
:::: my-r-code-header
::: {#cnj-042-most-basic-map}
: Most basic map from a {sf} data frame
:::
::::

::: my-r-code-container
```{r}
#| label: fig-042-most-basic-map
#| lst-label: lst-042-most-basic-map
#| fig-cap: "Basic map without adding tiles, created from {sf} data frame."
#| lst-cap: "Most basic map from a {sf} data frame"

rwb_map_2025 <- readRDS(paste0(here::here(), "/data/chap041/rwb_map_2025.rds"))

leaflet::leaflet(rwb_map_2025) |> 
  leaflet::addPolygons()
```

------------------------------------------------------------------------

It is interesting that {**leaflet**} centered the map automatically. I
do not know if this feature depends on the exclusion of
`leaflet::setView()` and/or `leaflet::addTiles()`.
:::
::::::

If I would have uses the standard `leaflet::addTiles()` the world view
would be the same. But zooming into a region would bring up the
`r glossary("OpenStreetMap")` default street map. (There are many
different types of maps [@king-nd].)

But to learn how to apply `leaflet::addProviderTiles()` I have used in
the next code chunk the free
[OpenTopoMap](https://leaflet-extras.github.io/leaflet-providers/preview/#filter=OpenTopoMap)
from [OpenStreetMap](https://www.openstreetmap.org/).

:::::: my-r-code
:::: my-r-code-header
::: {#cnj-042-opentopomap-tiles-demo}
: Demo: World map with freely available `OpenTopoMap` tiles from
`OpenStreetMap`
:::
::::

::: my-r-code-container
```{r}
#| label: fig-042-opentopomap-tiles-demo
#| lst-label: lst-042-opentopomap-tiles-demo
#| fig-cap: "Demo: World map with freely available `OpenTopoMap` tiles from `OpenStreetMap`"
#| lst-cap: "Basic map adding OpenTopoMap tiles"

leaflet::leaflet(rwb_map_2025) |> 
  leaflet::setView(0, 45, 2) |>
  leaflet::addProviderTiles(
    "OpenTopoMap",
    options = leaflet::tileOptions(noWrap = TRUE)
    ) |> 
  leaflet::addPolygons()
```

------------------------------------------------------------------------

(The line `options = leaflet::tileOptions(noWrap = TRUE)` is explained
in @sec-042-bounding-box.)

Another --- even more basic option --- would be to use just
`leaflet::addTiles()` instead of the line with
`leaflet::addProviderTiles(<provider name>)`.
:::
::::::

In @cnj-042-opentopomap-tiles-demo I have used
`specific leaflet::setView()` in anticipation of appropriate arguments
to center the map explained in the folowing section on 'Area selection'.

#### Area selection

The next problem for a nice choropleth map is to get the latitude and
longitude data for an appropriate area selection fitting in the plotting
bounding box. As I am using a world map I could try without these data,
but it turned in @fig-042-rwb-my-first-leaflet-example out, that this is
not a correct solution.

To get exact coordinates for **any** map I learned from [another
previous learning
enterprise](https://bookdown.org/pbaumgartner/gdswr-notes-new/91-creating-maps.html#zooming-into-a-specific-area)
following an article and video by FelixAnalytix [-@felixanalytix-2023;
-@felixanalytix-2023a] that
[OpenStreetMap](https://www.openstreetmap.org/) has a [nice
tool](https://www.openstreetmap.org/export) to get the coordinates of a
specific bounding box.

There are several options to get the coordinates of the bounding box for
Leaflet.

##### Center coordinates

(The next two paragraphs originate from the Brave-KI with the search
string "r leaflet latitude and longitude for world center point".)

> The geographic center of the world is not a single, universally
> agreed-upon point, but a commonly referenced location is the
> intersection of the Prime Meridian (0° longitude) and the Equator (0°
> latitude), which is located in the Gulf of Guinea, off the western
> coast of Africa This point is often used as a reference for the
> world's center in geographic and cartographic contexts.

> In the R programming language, when using the {**leaflet**} package,
> the `leaflet::setView()` function is used to center the map on a
> specific location by specifying the longitude and latitude. For the
> world center point, this would be set to longitude 0 and latitude 0.
> The {**leaflet**} package expects all point, line, and shape data to
> be specified in latitude and longitude using the WGS 84 coordinate
> reference system (EPSG:4326) For example, to center a map on the
> world's center point, you would use
> `leaflet::setView(lng = 0, lat = 0, zoom = 2)` within a
> `leaflet::leaflet()` object.

:::::: my-r-code
:::: my-r-code-header
::: {#cnj-042-world-map-centered-coordinates}
: World map with centered `0` coordinates
:::
::::

::: my-r-code-container
```{r}
#| label: fig-042-world-map-centered-coordinates
#| lst-label: lst-042-world-map-centered-coordinates
#| lst-cap: "World map with centered `0` coordinates using MapBox tiles"
#| fig-cap: "In my standard plotting configuration a world map with lng = 0 and lat = 0 is not correctly centered."

leaflet::leaflet(rwb_map_2025) |> 
  leaflet::setView(0, 0, 2) |> 
  leaflet::addProviderTiles(
      "MapBox", 
      options = leaflet::providerTileOptions(
            id = "mapbox.light",
            accessToken = Sys.getenv('MAPBOX_ACCESS_TOKEN')
            )
    ) |> 
    leaflet::addPolygons()
```
:::
::::::

::: {#imp-042-world-center-point .callout-important}
As I have already noticed in the [World tab of the Basic Map
section](https://bookdown.org/pbaumgartner/geocomputing-notes/97-learn-leaflet.html#basic-map),
because of the height-width ratio a small correction of the north/south
center point is necessary.

Although my RWB map does not contain Antarctica, the map is still too
big. Previously (see [World tab of the Basic Map
section](https://bookdown.org/pbaumgartner/geocomputing-notes/97-learn-leaflet.html#basic-map))
I believed that it is just a mater of the heigt-width ratio of the
figure. But now I think the situation is more complex:

Finding the best configuration to fit my plotting area depends on
several interacting parameters:

-   `lat` and `lng` coordinates,
-   zoom level,
-   width and height of the figure
-   aspect ration and the
-   layout (space) provided by Quarto

Another important issue affecting the center coordinates is the omission
of Antarctica in my world map!
:::

As in @imp-042-world-center-point explained, it is difficult to
understand the result of the different interacting factors. Therefore a
bit of experimentation is always necessary.

::::::: column-page-inset
:::::: my-r-code
:::: my-r-code-header
::: {#cnj-042-practical-center-coordinates}
: World map with theoretical and practical center coordinates
:::
::::

::: my-r-code-container
```{r}
#| label: fig-042-practical-center-coordinates
#| lst-label: lst-042-practical-center-coordinates
#| fig-cap: "World map centered after some experimentation with figure dimension, coordinates and Quarto layout. The markers show the difference between theoretical (0, 0) and practical (0, 45) center coordinates."
#| lst-cap: "World map centered after some experimentation showing theoretical (0, 0) and practical (0, 45) center coordinates"
#| fig-height: 8
#| fig-width: 7
#| echo: fenced

leaflet::leaflet(rwb_map_2025) |> 
  leaflet::setView(0, 45, 2) |>
  leaflet::addPolygons() |> 
  leaflet::addMarkers(0, 0, popup = 'Theretical center at 0,0') |> 
  leaflet::addMarkers(0, 45, popup = 'Practical center at 0,45')
```
:::
::::::
:::::::

##### Bounding box {#sec-042-bounding-box}

(The next two paragraphs originate from the Brave-KI with the search
string "r leaflet bounding box for a world map".)

> A function can be created to calculate the bounding box based on the
> map's center coordinates, zoom level, and the specified width and
> height of the map widget. This approach uses the formulae derived from
> Leaflet's tile grid system, where the longitude width is calculated as

$$360 \times \text{width} / 2^{(\text{zoom} + 8)}$$

and the latitude height as

$$360 \times \text{height} \times \cos(\text{lat}/180 \times \pi) / 2^{(\text{zoom} + 8)}$$

> The bounding box coordinates are then derived from the center point
> and these calculated extents This method is effective for maps with
> defined dimensions and a known zoom level, though accuracy can
> decrease at lower zoom levels.

> The maximum bounds for the entire world in Leaflet are defined by the
> coordinates $[-90, -180]$ (southwest corner) and $[90, 180]$
> (northeast corner), which represent the full range of latitude and
> longitude. To ensure the map displays only one instance of the world
> and prevents the display of duplicate world copies when panning, the
> `noWrap` option should be set to `true` when adding a tile layer, as I
> have done in @lst-042-rwb-my-first-leaflet-example.

I haven't tested the pretty complicated calculation for the bounding box
coordinates. It is easier to use the defined coordinates together with
the `noWrap` option already used in @lst-042-opentopomap-tiles-demo.

:::::: my-r-code
:::: my-r-code-header
::: {#cnj-042-bounding-box}
: World map with bounding box
:::
::::

::: my-r-code-container
```{r}
#| label: fig-042-bounding-box
#| lst-label: lst-042-bounding-box
#| fig-cap: "Demo: World map with freely available `OpenTopoMap` tiles from `OpenStreetMap`"
#| lst-cap: "Basic map adding OpenTopoMap tiles"

leaflet::leaflet(rwb_map_2025) |> 
  leaflet::setMaxBounds(-90, -180, 90, 180) |>
  leaflet::addProviderTiles(
    "OpenTopoMap",
    options = leaflet::tileOptions(noWrap = TRUE)
    ) |>
  leaflet::addPolygons()
```
:::
::::::

##### Selecting area manually

Another strategy is to set the bounding box in OpenStreetMap manually as
the following image shows:

![Selecting in OpenStreetMap a bounding area
manually](img/openstreetmap-bounding-box-world-min.png){#fig-042-openstreetmap
fig-alt="alt-text" fig-align="center" width="100%"}

I have set the bounding area for a world map without Antarctica. I used
the mouse to get the appropriate window on the right pane. The
coordinates appear on the left side. The coordinates -59.9 / -168.8
(bottom, left) represent `lat` and `lng` of the bottom left point. 85.0
/ -168.8 (top, right) are the coordinates for the top right point.

:::::: my-r-code
:::: my-r-code-header
::: {#cnj-042-bounding-area-manually}
: Setting the bounding area manually with OpenStreetMap tool
:::
::::

::: my-r-code-container
```{r}
#| label: fig-042-bounding-area-manually
#| lst-label: lst-042-bounding-area-manually
#| fig-cap: "World map with bounding area set manually"
#| lst-cap: "World map with bounding area set manually"

leaflet::leaflet(rwb_map_2025) |> 
  leaflet::setMaxBounds(-60, -170, 85, 170) |>
  leaflet::addProviderTiles(
    "OpenTopoMap",
    options = leaflet::tileOptions(noWrap = TRUE)
    ) |>
  leaflet::addPolygons()
```
:::
::::::

The results from @lst-042-bounding-area-manually and
@lst-042-bounding-box are very similar as their values differ only few
degrees. From the practical perspective to choose any region of the
world only the last option (setting the boundaries manually) is viable.

### Adding some color

Until now we have only use the default styling options for
`leaflet::addPolygons()`. It resulted in dark blue thick country border
lines and light blue background for the country areas.

An important part of spatial visualization is mapping variables to
colors. While R has no shortage of built-in functionality to map values
to colors, the {**leaflet**} developers found that there was enough
friction in the process to warrant introducing some wrapper functions
that do a lot of the work for you.

To that end, they’ve created a family of `color*()` convenience
functions that can be used to easily generate palette functions.
Essentially, you call the appropriate color function with

1)  the colors you want to use and
2)  optionally, the range of inputs (i.e., *domain*) that are expected.

The color function returns a palette function that can be passed a
vector of input values, and it’ll return a vector of colors in
`#RRGGBB(AA)` format.

There are currently three color functions for dealing with continuous
input: `leaflet::colorNumeric()`, `leaflet::colorBin()`, and
`leaflet::colorQuantile()`; and one for categorical input,
`leaflet::colorFactor()`.

:::::: my-r-code
:::: my-r-code-header
::: {#cnj-042-color-numeric-example}
: Using `leaflet::colorNumeric()` to demonstrate the function results
:::
::::

::: my-r-code-container
```{r}
#| label: 042-color-numeric-example
#| lst-label: lst-042-color-numeric-example
#| lst-cap: "Demonstration of the effects of `leaflet::colorNumeric()`"

# Call the color function (colorNumeric) to create a new palette function
pal <- leaflet::colorNumeric(c("red", "green", "blue"), 1:100)

# Pass the palette function a data vector to get the corresponding colors
pal(c(1, 6, 9, 20, 25, 29, 30, 31, 40, 45, 60, 90, 100))
```
:::
::::::

To understand the effect of the code in @lst-042-color-numeric-example
it is helpful to convert the resulting vector of colors from
`#RRGGBB(AA)` format to the colors themselves:

![Demonstration of the numeric leaflet color
function](img/colorNumeric-examples-min.png){#fig-041-042-color-numeric-example
fig-alt="alt-text" fig-align="center" width="100%"}

The three palette colors (red, green, blue) are equally spaced through
the domain (1 to 100). Depending of the actual data value, pal
interpolates the values and spits out the appropriate color for this
value. For instance in the example the range between red and green is
50, half of it (25) is a mixture between red and green. Low values are
different shades of red, values started from the middle value 25 gets
with their rising number greener until the reach the 50. From here the
blue color wins increasing effect.

The four color functions all have two required arguments, `palette` and
`domain`.

**The palette argument** specifies the colors to map the data to. This
argument can take one of several forms:

-   The name of a preset palette from the {**RColorBrewer**} package,
    e.g., "RdYlBu", "Accent", or "Greens".
-   The full name of the colorblind-friendly {**viridis**} palette:
    "magma", "inferno", "plasma", "viridis", "cividis", "rocket",
    "mako", or "turbo".
-   A character vector of RGB or named colors, e.g.,
    `grDevices::palette()`, `c("#000000", "#0000FF", "#FFFFFF")`,
    `grDevices::topo.colors(10)`.
-   A function that receives a single value between 0 and 1 and returns
    a color, e.g.,:
    `grDevices::colorRamp(c("#000000", "#FFFFFF"), interpolate="spline")`

**The domain argument** tells the color function the range of input
values. You can pass `NULL` here to create a palette function that
doesn’t have a preset range; the range will be inferred from the data
each time you invoke the palette function. If you use a palette function
multiple times across different data, it’s important to provide a
non-`NULL` value for `domain` so the scaling between data and colors is
consistent.

#### Continuous data

##### Continuous colors

The following graphics uses continuous colors to map continuous input.
We will map the {**sf**} data frame `rwb_map_20225` with its global
score values of the `r glossary("WPFI")` directly to the "Blues" palette
from [Color Brewer
2](https://colorbrewer2.org/#type=sequential&scheme=Blues&n=9). The
"Blues" palette only contains nine colors, but `leaflet::colorNumeric()`
interpolates these colors so we get continuous output.

(1) The **palette parameter** is the ordered list of colors you will map
    colors to. In this case we used a Color Brewer palette, but we
    could’ve used `c("white", "navy")` or `c("#FFFFFF", "#000080")` for
    a similar effect. You can also pass more than two colors, for a
    diverging palette for example. And for maximum flexibility, you can
    even pass a function that takes a numeric value over the interval
    \[0,1\] and returns a color.
(2) The **domain parameter** indicates the set of input values that we
    are mapping to these colors. For `leaflet::colorNumeric()`, you can
    provide either the full range of the data, a min/max value (11.32 /
    92.31) as in this example, or a set of numbers that
    `leaflet::colorNumeric()` can call `range()` on.
(3) The result is **pal()**, a function that can accept numeric vectors
    with values in the range `range(countries$gdp_md_est)` and return
    colors in `"#RRGGBB"` format.

::::::: column-page-inset
:::::: my-r-code
:::: my-r-code-header
::: {#cnj-042-continuous-colors}
: Choropleth map with continuous colors for 2025 WPF Index
:::
::::

::: my-r-code-container
```{r}
#| label: fig-042-continuous-colors
#| lst-label: lst-042-continuous-colors
#| fig-cap: "Choropleth map with continuous colors for the global score 2025 of the World Press Freedom Index"
#| lst-cap: "Choropleth map with continuous colors for the WPFI 2025"
#| fig-height: 8
#| fig-width: 7

rwb_map_2025 <- readRDS(paste0(here::here(), "/data/chap041/rwb_map_2025.rds"))

# Create a continuous palette function
pal <- leaflet::colorNumeric(      # (3)
  palette = "Blues",               # (1)
  domain = rwb_map_2025$score)     # (2)

leaflet::leaflet(rwb_map_2025) |> 
  leaflet::setView(0, 45, 2) |>
  leaflet::addPolygons(
    stroke = FALSE, 
    smoothFactor = 0.2, 
    fillOpacity = 1,
    color = ~pal(score)
  ) |> 
  leaflet::addLegend(pal = pal, values = ~score, opacity = 0.7, title = NULL,
  position = "bottomleft")
```
:::
::::::
:::::::

::: {#nte-042-added-legend .callout-note}
To see the differences of the various map scales I needed to add a
legend, a feature covered in detail in @sec-042-legend.
:::

Compare @fig-041-plot-map-draft1-2025 with @fig-042-continuous-colors.
Keep in mind that @fig-042-continuous-colors

-   does not have a `r glossary("CRS")`
-   does not use country border lines and
-   uses a bigger Quarto layout.

But besides these differences both figures are quite similar.

##### Discrete colors

Continuous input is mapped onto discrete colors with
`leaflet::colorBin()` and `leaflet::colorQuantile()`.

-   `leaflet::colorBin()` maps numeric input data to a fixed number of
    output colors using binning (slicing the input domain up by value).
-   `leaflet::colorQuantile()` maps numeric input data to a fixed number
    of output colors using quantiles by slicing the input domain into
    subsets with equal numbers of observations.

###### Binned

`leaflet::colorBin()` maps numeric input data to a fixed number of
output colors using binning (slicing the input domain up by value). To
divide input values into bins of equal range is only appropriate for
variables with a uniform distribution and is not recommended for
variables with a skewed distribution as the resulting map may end up
having little color diversity.

You can specify either the exact breaks to use, or the desired number of
bins. Note that in the latter case, if `pretty = TRUE` (the default)
you’ll end up with nice round breaks but not necessarily the number of
bins you wanted.

::::::: column-page-inset
:::::: my-r-code
:::: my-r-code-header
::: {#cnj-042-colors-binned}
: Choropleth map with discrete colors for 2025 WPF Index
:::
::::

::: my-r-code-container
```{r}
#| label: fig-042-colors-binned
#| lst-label: lst-042-colors-binned
#| fig-cap: "Choropleth map with fixed number of colors for the global score 2025 of the World Press Freedom Index"
#| lst-cap: "Choropleth map with discrete colors for the WPFI 2025"
#| fig-height: 8
#| fig-width: 7

rwb_map_2025 <- readRDS(paste0(here::here(), "/data/chap041/rwb_map_2025.rds"))

labels <- sprintf(
  "<strong>%s</strong><br/>score: %g",
  rwb_map_2025$country_en, rwb_map_2025$score
) |>  lapply(htmltools::HTML)

# Create a discrete palette function

binpal <- leaflet::colorBin(
  palette = "Blues", 
  domain = rwb_map_2025$score, 
  bins = 9, 
  pretty = TRUE)

leaflet::leaflet(rwb_map_2025) |> 
  leaflet::setView(0, 45, 2) |>
  leaflet::addPolygons(
    stroke = FALSE, 
    smoothFactor = 0.5, 
    fillOpacity = 1,
    color = ~binpal(score),
    label = labels
  ) |> 
  leaflet::addLegend(pal = binpal, values = ~score, opacity = 0.7, title = NULL,
  position = "bottomleft")
```
:::
::::::
:::::::

::: {#nte-042-pretty-true .callout-note}
I have use in @lst-042-colors-binned the `pretty = TRUE` argument,
otherwise I would get very weird bins starting with `11.320-20.319` and
ending with `83.311-92.310`. In this case I get with `pretty = TRUE` not
only nice boundaries but also the desired number of bins (nine).
:::

###### Quantiled

`leaflet::colorQuantile()` maps numeric input data to a fixed number of
output colors using quantiles (slicing the input domain into subsets
with equal numbers of observations). This has the potential disadvantage
that bin ranges can vary widely.

::::::: column-page-inset
:::::: my-r-code
:::: my-r-code-header
::: {#cnj-042-colors-quantile}
: Choropleth map with quantiled colors for 2025 WPF Index
:::
::::

::: my-r-code-container
```{r}
#| label: fig-042-colors-quantiled
#| lst-label: lst-042-colors-quantiled
#| fig-cap: "Choropleth map for the global score 2025 of the World Press Freedom Index. Every bin has the same numbers of observations."
#| lst-cap: "Choropleth map for the WPFI 2025 with fixed number of output colors using quantiles."
#| fig-height: 8
#| fig-width: 7

rwb_map_2025 <- readRDS(paste0(here::here(), "/data/chap041/rwb_map_2025.rds"))

labels <- sprintf(
  "<strong>%s</strong><br/>score: %g",
  rwb_map_2025$country_en, rwb_map_2025$score
) |>  lapply(htmltools::HTML)

# Create a discrete palette function

qpal <- leaflet::colorQuantile(
  palette = "Blues", 
  domain = rwb_map_2025$score, 
  n = 9
  )

leaflet::leaflet(rwb_map_2025) |> 
  leaflet::setView(0, 45, 2) |>
  leaflet::addPolygons(
    stroke = FALSE, 
    smoothFactor = 0.5, 
    fillOpacity = 1,
    color = ~qpal(score),
    label = labels
  ) |> 
  leaflet::addLegend(pal = qpal, values = ~score, opacity = 0.7, title = "Global score",
  position = "bottomleft")
```
:::
::::::
:::::::

::: {#nte-max-palette-colors .callout-note}
Both discrete color scales (@lst-042-colors-binned and
@lst-042-colors-quantiled) are generally limited by the maximum number
of palette colors. This in nine the case of "Blues". If you override
this maximum the program interpolated the colors with a warning message:

> Warning in RColorBrewer::brewer.pal(max(3, n), palette) : n too large,
> allowed maximum for palette Blues is 9 Returning the palette you asked
> for with that many colors
:::

#### Categorical data

For categorical data, use `leaflet::colorFactor()`. If the palette
contains the same number of elements as there are factor levels, then
the mapping will be 1:1; otherwise, the palette will be interpolated to
produce the desired number of colors.

You can specify the input domain either by passing a factor or character
vector to `domain`, or by providing levels directly using the `levels`
parameter (in which case the `domain` will be ignored).

::::::: column-page-inset
:::::: my-r-code
:::: my-r-code-header
::: {#cnj-042-colors-categorized}
: Choropleth map with colors representing categories (factors) for the
2025 WPF Index
:::
::::

::: my-r-code-container
```{r}
#| label: fig-042-colors-categorized
#| lst-label: lst-042-colors-categorized
#| fig-cap: "Choropleth map for the five levels of the global situation of the World Press Freedom Index."
#| lst-cap: "Choropleth map for the five levels of the global situation of the World Press Freedom Index."
#| fig-height: 8
#| fig-width: 7

rwb_map_2025 <- readRDS(paste0(here::here(), "/data/chap041/rwb_map_2025.rds"))

rwb_colors <- c("#c6e269", "#ecc33d", "#e29950", "#de643a", "#9f1714" )

labels <- sprintf(
  "<strong>%s</strong><br/>%s<br/>Score: %g",
  rwb_map_2025$country_en, rwb_map_2025$score_situation, rwb_map_2025$score 
) |>  lapply(htmltools::HTML)

# Create a discrete palette function

factpal <- leaflet::colorFactor(
  palette = rwb_colors, 
  domain = rwb_map_2025$score_situation, 
  levels = c("1. Good",
             "2. Rather Good",
             "3. Problematic",
             "4. Difficult",
             "5. Very Serious"
            )
  )

leaflet::leaflet(rwb_map_2025) |> 
  leaflet::setView(0, 45, 2) |>
  leaflet::addPolygons(
    fillColor = ~factpal(score_situation),
    fillOpacity = 1,
    smoothFactor = 0.5, 
    label = labels,
    stroke = TRUE, 
    weight = 2,
    opacity = 1,
    color = "white",
    dashArray = "3"
  ) |> 
  leaflet::addLegend(pal = factpal, values = ~score_situation, opacity = 1, title = "Score situation",
  position = "bottomleft")
```
:::
::::::
:::::::

::: {.callout-warning #wrn-042-leaflet-control-text-align-left}
###### Leaflet control needs CSS patch with `text-align: left;`

> When a leaflet map is included in a Quarto HTML report, any categorical
legend ends up centered when the chunk is labelled as a figure.
<https://github.com/quarto-dev/quarto-cli/issues/7843>

I provided my own rule to solve this issue:

```
.leaflet .info {
    text-align: left;
}
```

But this solved only the legend text and not other Leaflet controls (like `leaflet::addLayersControl()`). The solution for both kind of issues is:


```
div.leaflet-control {
  text-align: left;
}
```


See the extensive disussion in the [quarto-cli GitHub repo](https://github.com/quarto-dev/quarto-cli/issues/7843).
:::

### Adding interaction

The next thing we’ll want is to make the polygons highlight as the mouse
passes over them. The `leaflet::addPolygon()` function has a `highlight`
argument that makes this simple.

::::::: column-page-inset
:::::: my-r-code
:::: my-r-code-header
::: {#cnj-042-adding-interaction}
: Interactive choropleth map for the 2025 WPF Index
:::
::::

::: my-r-code-container
```{r}
#| label: fig-042-adding-interaction
#| lst-label: lst-042-adding-interaction
#| fig-cap: "Interactive choropleth map of the World Press Freedom Index 2025."
#| lst-cap: "Interactive choropleth map of the World Press Freedom Index 2025."
#| fig-height: 8
#| fig-width: 7

rwb_map_2025 <- readRDS(paste0(here::here(), "/data/chap041/rwb_map_2025.rds"))

rwb_colors <- c("#c6e269", "#ecc33d", "#e29950", "#de643a", "#9f1714" )

labels <- sprintf(
  "<strong>%s</strong><br/>%s<br/>Score: %g",
  rwb_map_2025$country_en, rwb_map_2025$score_situation, rwb_map_2025$score 
) |>  lapply(htmltools::HTML)

# Create a discrete palette function

factpal <- leaflet::colorFactor(
  palette = rwb_colors, 
  domain = rwb_map_2025$score_situation, 
  levels = c("1. Good",
             "2. Rather Good",
             "3. Problematic",
             "4. Difficult",
             "5. Very Serious"
            )
  )

leaflet::leaflet(rwb_map_2025) |> 
  leaflet::setView(0, 45, 2) |>
  leaflet::addPolygons(
    fillOpacity = 1,
    fillColor = ~factpal(score_situation),
    smoothFactor = 0.5, 
    label = labels,
    stroke = TRUE, 
    weight = 2,
    opacity = 1,
    color = "white",
    dashArray = "3",
    highlightOptions = leaflet::highlightOptions(
    weight = 2,
    color = "black",
    dashArray = "",
    fillOpacity = 1,
    bringToFront = TRUE)
  ) |> 
  leaflet::addLegend(pal = factpal, values = ~score_situation, opacity = 1, title = NULL,
  position = "bottomleft")
```
:::
::::::
:::::::

(The Leaflet.js tutorial also adds an event handler that zooms into a
state when it’s clicked. This isn’t currently possible with the
{**leaflet**} R package, except with either custom JavaScript or using
{**shiny**}, both of which are outside the scope of this example.)

### Custom Info

Now let’s explain how to expose the state names and values to the user,
as I already have done.

The Leaflet.js tutorial shows the hovered-over state’s information in a
custom control. Again, that’s possible by adding custom JavaScript or
using Shiny, but for this example we’ll use the built-in labels feature
instead.

We’ll generate the labels by handcrafting some HTML, and passing it to
`base::lapply(htmltools::HTML)` so that Leaflet knows to treat each
label as HTML instead of as plain text. We’ll also set some label
options to improve the style of the label element itself.

::: {#imp-042-line-breaks .callout-important}
###### Use base::sprintf() or {leafpop} for line breaks

It is difficult to use popup information spread over several lines. The
best general way is to use the `base::stringf()` function.
`base::paste()` or `base::cat()` do not work.

Another way to display feature from the datasets using several lines is
to apply the `leafpop::popupTable()` function of the {**leafpop**}
package.

The advantage of `base::stringf()` is that you can adapt the popup
string to your needs. With `leafpop::popupTable()` you have to stick
with the name and content of the columns. But if you prepare the dataset
to your needs then `leafpop::popupTable()` is way more comfortable to
use.
:::

::::::: column-page-inset
:::::: my-r-code
:::: my-r-code-header
::: {#cnj-042-custom-info}
: Interactive choropleth map for the 2025 WPF Index with popup info by
mouse hovering
:::
::::

::: my-r-code-container
```{r}
#| label: fig-042-custom-info
#| lst-label: lst-042-custom-info
#| fig-cap: "Interactive choropleth map of the World Press Freedom Index 2025 with popup infos."
#| lst-cap: "Interactive choropleth map of the World Press Freedom Index 2025 with popup infos."
#| fig-height: 8
#| fig-width: 7

rwb_map_2025 <- readRDS(paste0(here::here(), "/data/chap041/rwb_map_2025.rds"))

rwb_colors <- c("#c6e269", "#ecc33d", "#e29950", "#de643a", "#9f1714" )

labels <- sprintf(
  "<strong>%s</strong><br/>%s<br/>Score: %g",
  rwb_map_2025$country_en, rwb_map_2025$score_situation, rwb_map_2025$score 
) |>  lapply(htmltools::HTML)

# Create a discrete palette function

factpal <- leaflet::colorFactor(
  palette = rwb_colors, 
  domain = rwb_map_2025$score_situation, 
  levels = c("1. Good",
             "2. Rather Good",
             "3. Problematic",
             "4. Difficult",
             "5. Very Serious"
            )
  )

leaflet::leaflet(rwb_map_2025) |> 
  leaflet::setView(0, 45, 2) |>
  leaflet::addPolygons(
    fillOpacity = 1,
    fillColor = ~factpal(score_situation),
    smoothFactor = 0.5, 
    label = labels,
    labelOptions = leaflet::labelOptions(
      style = list("font-weight" = "normal", padding = "3px 8px"),
      textsize = "15px",
      direction = "auto"
      ),
    stroke = TRUE, 
    weight = 2,
    opacity = 1,
    color = "white",
    dashArray = "3",
    highlightOptions = leaflet::highlightOptions(
    weight = 2,
    color = "black",
    dashArray = "",
    fillOpacity = 1,
    bringToFront = TRUE)
  ) |> 
  leaflet::addLegend(pal = factpal, values = ~score_situation, opacity = 1, title = NULL,
  position = "bottomleft")
```
:::
::::::
:::::::

@lst-042-custom-info contains the last version of the polygon layer.

### Legend {#sec-042-legend}

As our final step, let’s add a legend. Because we chose to color our map
using one of the `color*()` convenience functions, the
leaflet::addLegend() function makes it particularly easy to add a legend
with the correct colors and intervals.

I have this already done in @lst-042-continuous-colors and the following
code chunks. Here I will display the last version of the polygon layer
as in @lst-042-custom-info but for the continuous color scale.

::::::: column-page-inset
:::::: my-r-code
:::: my-r-code-header
::: {#cnj-042-continuous-color-scale-with-legend}
: Choropleth map with continuous color scale with legend and all the
other explained features
:::
::::

::: my-r-code-container
```{r}
#| label: fig-042-continuous-color-scale-with-legend
#| lst-label: lst-042-continuous-color-scale-with-legend
#| fig-cap: "Choropleth map with continuous color scale with legend and all the other explained features"
#| lst-cap: "Choropleth map with continuous color scale with legend and all the other explained features"
#| fig-height: 8
#| fig-width: 7

rwb_map_2025 <- readRDS(paste0(here::here(), "/data/chap041/rwb_map_2025.rds"))

labels <- sprintf(
  "<strong>%s</strong><br/>score: %g",
  rwb_map_2025$country_en, rwb_map_2025$score
) |>  lapply(htmltools::HTML)

pal <- leaflet::colorNumeric(      
  palette = "Blues",               
  domain = rwb_map_2025$score)     

leaflet::leaflet(rwb_map_2025) |> 
  leaflet::setView(0, 45, 2) |>
  leaflet::addPolygons(
    fillOpacity = 1,
    fillColor = ~pal(score),
    smoothFactor = 0.5, 
    label = labels,
    labelOptions = leaflet::labelOptions(
      style = list("font-weight" = "normal", padding = "3px 8px"),
      textsize = "15px",
      direction = "auto"
      ),
    stroke = TRUE, 
    weight = 2,
    opacity = 1,
    color = "white",
    dashArray = "3",
    highlightOptions = leaflet::highlightOptions(
    weight = 2,
    color = "black",
    dashArray = "",
    fillOpacity = 1,
    bringToFront = TRUE)
  ) |> 
  leaflet::addLegend(pal = pal, values = ~score, opacity = 1, title = "Global score",
  position = "bottomleft")
```
:::
::::::
:::::::

## Popups and Labels {#sec-042-popups-and-labels}

### Popups

Popups are small boxes containing arbitrary HTML, that point to a
specific point on the map. In contrast to the labels in
`leaflet::addPolygons()` that takes information from the dataset (see:
@imp-042-line-breaks), base::paste() works for line breaks.

Use the `leaflet::addPopups()` function to add standalone popup to the
map.

:::::: my-r-code
:::: my-r-code-header
::: {#cnj-042-popups}
: Using popups
:::
::::

::: my-r-code-container
```{r}
#| label: fig-042-popups
#| lst-label: lst-042-popups
#| fig-cap: "A demonstration of using popups with the {leaflet} package"
#| lst-cap: "Providing the coordinates of the Hundertwasser house in Vienna for a standalone popup"

content <- base::paste(sep = "<br/>",
  "<b><a href='https://en.wikipedia.org/wiki/Hundertwasserhaus'>Hundertwasser house</a> in Vienna (Austria)</b>",
  "Kegelgasse 36-38, 1030 Wien",
  "at the corner Kegelgasse and Löwengasse in district 3"
)



leaflet::leaflet() |>  
  leaflet::addTiles() |> 
  leaflet::addPopups(
    lng = 16.394287715350963, 
    lat = 48.207380313634765, 
    popup = content,
    options = leaflet::popupOptions(closeButton = FALSE)
  )

```
:::
::::::

::: {#imp-042-google-map-coordinates .callout-important}
##### The coordinates from Google map are in `lat lng` format

When using the standard argument sequence of {**leaflet**} without
parameter names then one must reserve the Google map coordinates.
:::

A common use for popups is to have them appear when markers or shapes
are clicked. Marker and shape functions in the {**leaflet**} package
take a popup argument, where you can pass in HTML to easily attach a
simple popup.

An example for my `r glossary("RWB")` use case would be to set a marker
for a specific country to show where it is situated in the world map. In
the following demonstration the marker shows where Austria is situated.
Clicking on the marker could give you more detailed information on the
country.

::::::: column-page-inset
:::::: my-r-code
:::: my-r-code-header
::: {#cnj-042-popup-for-austria}
: Choropleth map with continuous color scale with legend and all the
other explained features
:::
::::

::: my-r-code-container
```{r}
#| label: fig-042-popup-for-austria
#| lst-label: lst-042-popup-for-austria
#| fig-cap: "Choropleth map with a single marker over Vienna (Austria)"
#| lst-cap: "Choropleth map with a single marker over Vienna (Austria)"
#| fig-height: 8
#| fig-width: 7

rwb_map_2025 <- readRDS(paste0(here::here(), "/data/chap041/rwb_map_2025.rds"))

info_austria <- tibble::as_tibble(rwb_map_2025) |> 
  dplyr::filter(country_en == "Austria") |> 
  dplyr::pull(country_en)


pal <- leaflet::colorNumeric(      
  palette = "Blues",               
  domain = rwb_map_2025$score)     

leaflet::leaflet(rwb_map_2025) |> 
  leaflet::setView(0, 45, 2) |>
  leaflet::addPolygons(
    fillOpacity = 1,
    fillColor = ~pal(score),
    smoothFactor = 0.5, 
    stroke = TRUE, 
    weight = 2,
    opacity = 1,
    color = "white",
    dashArray = "3"
  ) |> 
  leaflet::addMarkers(
    lng = ~16.363449, 
    lat = ~48.210033, 
    popup = info_austria
  ) |> 
  leaflet::addLegend(pal = pal, values = ~score, opacity = 1, title = "Global score",
  position = "bottomleft")
```
:::
::::::
:::::::


::: {#nte-042-improvement-required .callout-note}
###### My example needs improvement

I am not happy with example in @lst-042-popup-for-austria. I would need
a solution where the marker coordinates are generated automatically and
where I could add more information on this country when the user clicks
the marker.

To get this improvement I would need a dataset with the latitude and
longitude information of capital cities.
:::

:::::: my-resource
:::: my-resource-header
::: {#lem-042-capital-cities}
: Capital cities
:::
::::

::: my-resource-container
My research to get a dataset of capital cities resulted in the following
list:

-   [{ggmap}](https://github.com/dkahle/ggmap) is an R package that
    makes it easy to retrieve raster map tiles from popular online
    mapping services like [Google
    Maps](https://developers.google.com/maps/documentation/maps-static?hl=en)[^042-learn-leaflet-2],
    [Stadia Maps](https://stadiamaps.com/)[^042-learn-leaflet-3], and
    [OpenStreetMap](https://www.openstreetmap.org/), and plot them using
    the {**ggplot2**} framework. The important thing here is that {**ggmap**} has a function
    `ggmap::geocode()` which uses Google Maps to geocode cities. But besides the cumbersome registration procedure it has also the
    disadvantage that you would have to build a database of all the capital cities by yourself.
-   [{maps}](https://github.com/adeckmyn/maps) includes a dataset of world cities `maps::world.cities` of population greater than about 40,000. Also included are capital cities of any population size, and many smaller towns. But it lacks ISO codes to join with other (country) datasets and some of its data from 2006 may be already outdated.
-   [simplemaps](https://simplemaps.com/data), a company product of Pareto Software provides interactive map software for websites. There is an up-to-date (May 11, 2025) and free (CC-BY 4.0) [World Cities Database](https://simplemaps.com/data/world-cities) in CSV and Excel format covering about 48000 entries with `r glossary("ISO 3166 Country Codes")` and cities of different administrative levels with their coordinates and populations size. I have stored the full `r glossary("CSV")` version with 4.9 MB in `"/data/chap042/worldcities.csv"`. 
:::
::::::

[^042-learn-leaflet-2]: Google Maps needs registration and API key. See
    [Google Maps API key](Google Maps API key) for details.

[^042-learn-leaflet-3]: Stadia Maps need also registration and API key.
    See [Stadia
    Maps](https://github.com/dkahle/ggmap?tab=readme-ov-file#stadia-maps)
    for details.
    
:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-042-load-save-world-cities}
: Inspect the World Cities Database downloaded from [simplemaps](https://simplemaps.com/data/world-cities)
::::::
:::
::::{.my-r-code-container}

<center>**Run this code chunk manually if the file(s) still needs to be downloaded.**</center>

```{r}
#| label: 042-load-save-world-cities
#| lst-label: lst-042-load-save-world-cities
#| lst-cap: "Load and save the World Cities Database from simplemaps as `.rds` file"
#| results: hold
#| eval: false

world_cities <- vroom::vroom(
  file = paste0(here::here(), "/data/chap042/worldcities.csv"),
  delim = ",",
  show_col_types = FALSE
)

dplyr::glimpse(world_cities)

my_save_data_file("chap042", world_cities, "world_cities.rds")
```

***

<center>(*For this R code chunk is no output available*)</center>


::::
:::::

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-042-inspect-structure-world-cities}
: Inspect the structure of the World Cities Database (`world_cities.rds`)
::::::
:::
::::{.my-r-code-container}
```{r}
#| label: inspect-structure-world-cities
#| lst-label: lst-042-inspect-structure-world-cities
#| lst-cap: Inspect the structure of the World Cities Database (`world_cities.rds`)

world_cities <- readRDS(paste0(here::here(), "/data/chap042/world_cities.rds"))

dplyr::glimpse(world_cities)
```

::::
:::::

From the eleven columns I will **de**select:

- city (`city_ascii` is better because it contains only `r glossary("ASCII")` characters)
- iso2 (`iso3` code is mor common and used in my RWB dataset)
- admin_name (`city_ascii` is better because it does not use the locally official name which is not so well know and is used in my RWB data)
- id (not relevant for my work)

Additionally I will only use rows with capital cities `dplyr::filter(capital == primary)`.

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-042-capital-cities}
: Prepare dataset with capital cities
::::::
:::
::::{.my-r-code-container}

<center>**Run this code chunk manually if the file(s) still needs to be downloaded.**</center>

```{r}
#| label: capital-cities
#| lst-label: lst-042-capital-cities
#| lst-cap: Create dataset with capital cities
#| eval: false

world_cities <- readRDS(paste0(here::here(), "/data/chap042/world_cities.rds"))

capital_cities <- world_cities |> 
    dplyr::select(-c(city, iso2, admin_name, id)) |> 
    dplyr::filter(capital == "primary")
  
my_save_data_file("chap042", capital_cities, "capital_cities.rds")

```

***

<center>(*For this R code chunk is no output available*)</center>

::::
:::::

The last step is to join the RWB data with the capital city dataset. This requires some reorganization of the datasets, because we have two different `geometry` column: One for the country area, the other one for the capital city coordinates.  But for one dataset there is only one `geometry` column allowed.

::::::: column-page-inset
:::::: my-r-code
:::: my-r-code-header
::: {#cnj-042-countries-with-capital-cities}
: Choropleth map with information connected with capital city marker for one country
:::
::::

::: my-r-code-container
```{r}
#| label: fig-042-countries-with-capital-cities
#| lst-label: 042-countries-with-capital-cities
#| fig-cap: "Choropleth map with country information connected with single marker over Vienna (Austria)"
#| lst-cap: "Choropleth map with information connected with capital city marker for one country"
#| fig-height: 8
#| fig-width: 7

## get RWB country dataset
rwb_map_2025 <- readRDS(paste0(here::here(), "/data/chap041/rwb_map_2025.rds"))

## get capital cities dataset
capital_cities <- readRDS(paste0(here::here(), "/data/chap042/capital_cities.rds"))


## country dataset without geometry column
rwb_2025 <- rwb_map_2025 |> 
  sf::st_drop_geometry()

## converting longitude & latitude coordinates into geometry column
capital_cities2 <- capital_cities |> 
   sf::st_as_sf(coords = c("lng", "lat"), crs = 4326) 

## combining country with  capital city dataset
## new datasets need to be {sf} type
rwb_cities_2025 <- dplyr::left_join(
  rwb_2025,
  capital_cities2,
  by = dplyr::join_by(iso == iso3)
) |> 
  sf::st_as_sf()

## filtering the new enlarged dataset 
## to filter the desired country/capital city
info_austria <- rwb_cities_2025 |> 
  dplyr::filter(country == "Austria")

## here starts the code already used in other examples
pal <- leaflet::colorNumeric(      
  palette = "Blues",               
  domain = rwb_cities_2025$score)     

leaflet::leaflet(rwb_map_2025) |> # country data with geometry
  leaflet::setView(0, 45, 2) |>
  leaflet::addPolygons(
    fillOpacity = 1,
    fillColor = ~pal(score),
    smoothFactor = 0.5, 
    stroke = TRUE, 
    weight = 2,
    opacity = 1,
    color = "white",
    dashArray = "3"
  ) |> 
  leaflet::addMarkers(
    data = info_austria,
    popup = leafpop::popupTable( # Austrian data
      info_austria,
      feature.id = FALSE, 
      row.numbers = FALSE,
      zcol = c(
               "country", 
               "score", "score_situation", "rank",
               "political", "political_situation", "rank_pol",
               "economic", "economic_situation", "rank_eco",
               "legal", "legal_situation", "rank_leg",
               "social", "social_situation", "rank_soc",
               "safety", "safety_situation", "rank_saf",
               "city_ascii", "population"
      ),
    ) 
  ) |> 
  leaflet::addLegend(pal = pal, values = ~score, opacity = 1, title = "Global score",
  position = "bottomleft")
```
:::
::::::
:::::::

### Labels

A label is a textual or HTML content that can attached to markers and shapes to be always displayed or displayed on mouse over. Unlike popups you don’t need to click a marker/polygon for the label to be shown.

You can customize marker labels using the `leaflet::labelOptions` argument of the `leaflet::addMarkers()` function. The `leaflet::labelOptions` argument can be populated using the `leaflet::labelOptions()` function. If `noHide` is false (the default) then the label is displayed only when you hover the mouse over the marker; if `noHide` is set to true then the label is always displayed.

You can create labels without the accompanying markers using the `leaflet::addLabelOnlyMarkers()` function.

::::::: column-page-inset
:::::: my-r-code
:::: my-r-code-header
::: {#cnj-042-countries-with-capital-cities}
: Choropleth map with information connected with capital city marker for one country
:::
::::

::: my-r-code-container
```{r}
#| label: fig-042-countries-with-capital-cities-labels
#| lst-label: 042-countries-with-capital-cities-labels
#| fig-cap: "Choropleth map with country information labels displayed over Vienna (Austria)"
#| lst-cap: "Choropleth map with information displaye for Austria"
#| fig-height: 8
#| fig-width: 7


info_austria2 <-  info_austria |> 
  sf::st_coordinates() |> 
  tibble::as_tibble()

leaflet::leaflet(rwb_map_2025) |> # country data with geometry
  leaflet::setView(0, 45, 2) |>
  leaflet::addPolygons(
    fillOpacity = 1,
    fillColor = ~pal(score),
    smoothFactor = 0.5, 
    stroke = TRUE, 
    weight = 2,
    opacity = 1,
    color = "white",
    dashArray = "3"
  ) |> 
  leaflet::addMarkers(
    lng = info_austria2$X,
    lat = info_austria2$Y,
    label = ~htmltools::HTML(
      leafpop::popupTable(
        info_austria,
        row.numbers = FALSE, feature.id = FALSE,
        zcol = c(36, 1, 3:20)
      )
    ),
    labelOptions = labelOptions(noHide = TRUE, direction = "bottom",
      style = list(
        "color" = "red",
        "text-align" = "left",
        "font-family" = "serif",
        "box-shadow" = "3px 3px rgba(0,0,0,0.25)",
        "font-size" = "12px",
        "border-color" = "rgba(0,0,0,0.5)"
        )
      )
  ) |> 
  leaflet::addLegend(pal = pal, values = ~score, opacity = 1, title = "Global score",
  position = "bottomleft")
```
:::
::::::
:::::::

## SHow/Hide Layers

The Leaflet package includes functions to show and hide map layers. You can allow users to decide what layers to show and hide, or programmatically control the visibility of layers using [server-side code in Shiny](https://rstudio.github.io/leaflet/articles/shiny.html).

In both cases, the fundamental unit of showing/hiding is the **group.**

### Understanding Groups

A group is a label given to a set of layers. You assign layers to groups by using the group parameter when adding the layers to the map.

```{r}
#| label: demo-groups
#| eval: false

leaflet() |>  
  addTiles() |>
  addMarkers(data = coffee_shops, group = "Food & Drink") |>
  addMarkers(data = restaurants, group = "Food & Drink") |>
  addMarkers(data = restrooms, group = "Restrooms")
```

Many layers can belong to same group. But each layer can only belong to zero or one groups (you can’t assign a layer to two groups).

**Groups vs. Layer IDs**

Groups and [Layer IDs](https://rstudio.github.io/leaflet/articles/shiny.html#understanding-layer-ids) may appear similar, in that both are used to assign a name to a layer. However, they differ in that layer IDs are used to provide a [unique identifier to individual]{.mark} markers and shapes, etc., while groups are used to give [shared labels to many]{.mark} items.

You generally provide one group value for the entire `leaflet::addMarkers()` call, and you can reuse that same group value in future `leaflet::add*()` calls to add to that group’s membership (as in the example above).

`layerId` arguments are *always* vectorized: when calling e.g., `leaflet::addMarkers()` you need to provide one layer ID per marker, and they must all be unique. If you add a circle with a layer ID of `"foo"` and later add a different shape with the same layer ID, the original circle will be removed.

::: {.callout-note #nte-groups-vs-layers}
##### Differences between group and layer ID not yet clear for me

I do not understand what the differences are, because I am lacking knowledge about layers ID as well as about groups. I hope that this issue will be clarified later on.
:::

### Interactive Layer Display

You can use Leaflet’s layers control feature to allow users to toggle the visibility of groups.

This time I will copy the example from the documentation. If I understand the concept better I will try to use my own RWB dataset.

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-042-interactive-layer-display-demo}
: Demonstration of interactive layer display with earth quake data
::::::
:::
::::{.my-r-code-container}
```{r}
#| label: fig-042-interactive-layer-display-demo
#| lst-label: lst-042-interactive-layer-display-demo
#| fig-cap: "Demonstration of interactive layer display with earth quake data"
#| lst-cap: "Demonstration of interactive layer display with earth quake data"

outline <- quakes[chull(quakes$long, quakes$lat),]

map <- leaflet::leaflet(quakes) |>
  # Base groups
  leaflet::addTiles(group = "OSM (default)") |>
  leaflet::addProviderTiles(
    leaflet::providers$CartoDB.Positron, group = "Positron (minimal)") |>
  leaflet::addProviderTiles(
    leaflet::providers$Esri.WorldImagery, group = "World Imagery (satellite)") |>
  # Overlay groups
  leaflet::addCircles(
    ~ long,
    ~ lat,
    ~ 10 ^ mag / 5,
    stroke = FALSE,
    group = "Quakes",
    fillColor = "tomato"
  ) |>
  leaflet::addPolygons(
    data = outline,
    lng = ~ long,
    lat = ~ lat,
    fill = FALSE,
    weight = 2,
    color = "#FFFFCC",
    group = "Outline"
  ) |>
  # Layers control
  leaflet::addLayersControl(
    baseGroups = c(
      "OSM (default)",
      "Positron (minimal)",
      "World Imagery (satellite)"
    ),
    overlayGroups = c("Quakes", "Outline"),
    options = leaflet::layersControlOptions(collapsed = FALSE)
  )

map
```

::::
:::::

::: {.callout-note #nte-leaflet-providers}
##### Where to get Leaflet providers?

The Leaflet providers are stored in the {**leaflet.extras**} package and can be inspected with mini maps on the [Leaflet-provider preview](https://leaflet-extras.github.io/leaflet-providers/preview/). Choosing the desired provider you will also get on this page the exact code for the provider name.
:::

`leaflet::addLayersControl()` distinguishes between base groups, which can only be viewed one group at a time, and overlay groups, which can be individually checked or unchecked.

Although base groups are generally tile layers, and overlay groups are usually markers and shapes, there is no restriction on what types of layers can be placed in each category.

Only one layers control can be present on a map at a time. If you call `leaflet::addLayersControl()` multiple times, the last call will win.

### Programmatic Layer Display

You can use `leaflet::showGroup()` and `leaflet::hideGroup()` to show and hide groups from code. This mostly makes sense in a [Shiny context with `leafletProxy`](https://rstudio.github.io/leaflet/articles/shiny.html), where perhaps you might toggle group visibility based on input controls in a sidebar.

You can also use `leaflet::showGroup()`/`leaflet::hideGroup()` in conjunction with `leaflet::addLayersControl()` to set which groups are checked by default.

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-042-show-hide-group}
: Example shows how to hide a group
::::::
:::
::::{.my-r-code-container}
```{r}
#| label: fig-042-show-hide-group
#| lst-label: lst-042-show-hide-group
#| lst-cap: "Hide the outline group"
#| fig-cap: "Example shows how to hide a group. In this case the outline is hidden. Compare this figure with @fig-042-interactive-layer-display-demo"

map |>  hideGroup("Outline")
```

::::
:::::

Finally, you can remove the layers in a group using `leaflet::clearGroup()`. Note that this doesn’t just remove the layers from the group, it also removes them from the map. (It does not, however, remove the group itself from the map; it still exists, but is empty.)

### With Markers Cluster

If markers are added to different groups, and when using marker clustering as described in the [marker page](https://rstudio.github.io/leaflet/articles/markers.html), {**leaflet**} will generate different sets of clusters for different groups. This allows showing/hiding of marker clusters belonging to a group independently of other marker clusters in other groups.

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-042-layers-and-marker-clusters}
: Show / hide layers with marker clusters
::::::
:::
::::{.my-r-code-container}
```{r}
#| label: fig-042-layers-and-marker-clusters
#| lst-label: lst-042-layers-and-marker-clusters
#| lst-cap: "Show / hide layers with marker clusters"
#| fig-cap: "Show / hide layers with marker clusters. Click at the colored circle to see the clustered markers"


quakes <- quakes |>
  dplyr::mutate(mag.level = cut(mag,c(3,4,5,6),
                                labels = c('>3 & <=4', '>4 & <=5', '>5 & <=6')))

quakes.df <- base::split(quakes, quakes$mag.level)

l <- leaflet::leaflet() |> leaflet::addTiles()

base::names(quakes.df) |>
  purrr::walk( function(df) {
    l <<- l |>
      leaflet::addMarkers(
        data = quakes.df[[df]],
        lng =  ~ long,
        lat =  ~ lat,
        label =  ~ as.character(mag),
        popup =  ~ as.character(mag),
        group = df,
        clusterOptions = leaflet::markerClusterOptions(removeOutsideVisibleBounds = FALSE),
        labelOptions = leaflet::labelOptions(noHide = FALSE, direction = 'auto')
      )
  })

l |>
  leaflet::addLayersControl(
    overlayGroups = base::names(quakes.df),
    options = leaflet::layersControlOptions(collapsed = FALSE)
  )
```

::::
:::::

### Layers with RWB data

This section end here with the complex example in @cnj-042-layers-and-marker-clusters.

The question arises: How can I apply the show/hide layers feature to my RWB data? Several options come to my mind:

- Different layers for different years
- Different layers for the different components of the global score.

I will try the second option with my `rwb_map_2025` data.

::: {.column-page-inset}

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-042-score-component-layers}
: RWB global score 2025 and its different component scores as layers
::::::
:::
::::{.my-r-code-container}
```{r}
#| label: fig-042-score-component-layers
#| lst-label: lst-042-score-component-layers
#| lst-cap: "RWB global score 2025 with its component scores as different layers"
#| fig-cap: "RWB global score 2025 with its component scores as different layers"
#| fig-height: 8
#| fig-width: 7

rwb_map_2025 <- readRDS(paste0(here::here(), "/data/chap041/rwb_map_2025.rds"))

labels <- sprintf(
  "<strong>%s</strong><br/>Global score: %g",
  rwb_map_2025$country_en, rwb_map_2025$score
) |>  lapply(htmltools::HTML)

economic_labels <- sprintf(
  "<strong>%s</strong><br/>Economical Score: %g",
  rwb_map_2025$country_en, rwb_map_2025$economic
) |>  lapply(htmltools::HTML)

# Create a discrete palette function

binpal <- leaflet::colorBin(
  palette = "Blues", 
  domain = rwb_map_2025$score, 
  bins = 9, 
  pretty = TRUE)

economic_binpal <- leaflet::colorBin(
  palette = "Blues", 
  domain = rwb_map_2025$economic, 
  bins = 9, 
  pretty = TRUE)

leaflet::leaflet(rwb_map_2025) |> 
  leaflet::setView(0, 45, 2) |>
  leaflet::addPolygons(
    stroke = TRUE, 
    weight = 2,
    color = "white",
    dashArray = "3",
    opacity = 1,
    smoothFactor = 0.5, 
    fillOpacity = 1,
    fillColor = ~binpal(score),
    label = labels,
    group = "Global Score",
    highlightOptions = leaflet::highlightOptions(
    weight = 2,
    color = "black",
    dashArray = "",
    fillOpacity = 1,
    bringToFront = TRUE)
  ) |> 
    leaflet::addPolygons(
    stroke = TRUE,
    weight = 2,
    color = "white",
    dashArray = "3",
    opacity = 1,
    smoothFactor = 0.5, 
    fillOpacity = 1,
    fillColor = ~economic_binpal(economic),
    label = economic_labels,
    group = "Economical Score",
    highlightOptions = leaflet::highlightOptions(
    weight = 2,
    color = "black",
    dashArray = "",
    fillOpacity = 1,
    bringToFront = TRUE)
  ) |> 
  # Layers control
  leaflet::addLayersControl(
    baseGroups = c(
      "Global Score",
      "Economical Score"
    ),
    options = leaflet::layersControlOptions(collapsed = FALSE)
  ) |> 
  leaflet::addLegend(pal = binpal, values = ~score, opacity = 0.7, title = NULL,
  position = "bottomleft")
```

::::
:::::

::: 


::: {.callout-note #nte-042-layers-vs-shiny}
##### Layers in Shiny?

To choose between different layers is a very nice {**leaflet**} option. But I am not sure if I need this feature using {**shiny**}. With Shiny I could control the option outside Leaflet and then programmatically control the options of the map.
:::

## Add Markers to Leaflet

For my use case of `r glossary("choropleth")` maps I do not need specialized marker. The only occasion I could image is to show country data as line graphs, scatterplots, bump graphs, tables etc. where a small map with a marker at the country position could helpful. (See my experiments in "Popup and Labels" @sec-042-popups-and-labels).

Another possibility I could imagine is to highlight the best / worst five countries with markers for different absolute scores or changes from one year to the next. This could be a nice supplement to the continuous or discrete map color distribution.


But these ideas are somewhat far fetched, respectively not essential to my planned dashboard. Therefore I will skip the article ["Add Markers to Leaflet"](https://rstudio.github.io/leaflet/articles/markers.html) for the moment (2025-08-21). If I really would need this feature then I will come back here and experiment with the settings for adding markers.

## Legends

Again I will skip this section on [Legends](https://rstudio.github.io/leaflet/articles/legends.html) as I have already incorporated different legends into my maps. For specialized needs I will come back to this section.

## Lines and Shapes

For choropleth maps I have no special needs at the moment for the article on [Lines and Shapes](https://rstudio.github.io/leaflet/articles/shapes.html). Highlights I have already used, circles and rectangles are not of any concern at the moment. One exception why I would get into this section in a detailed learning mode might be the simplification of complex polygons by using the {**rmapshaper**} package, which does topology-preserving simplification from R.

## Using Basemaps

Leaflet supports basemaps using [map tiles](https://www.mapbox.com/guides/how-web-maps-work/), popularized by Google Maps and now used by nearly all interactive web maps.

AT the world level the choice of basemaps are not important in choropleth maps. But when you zoom into a region {**leaflet**} shows the details of the region using the underlying basemap.

Default [OpenStreetMap](https://www.openstreetmap.org/) Tiles

The easiest way to add tiles is by calling `leaflet::addTiles()` with no arguments; by default, `r glossary("OpenStreetMap")` tiles are used. [OpenStreetMap](https://www.openstreetmap.org/) tiles are generally sufficient for my choropleth use case. So I do not continue to follow the rest of the article on [Using Basemaps](https://rstudio.github.io/leaflet/articles/basemaps.html).

## Working with GeoJSON & TopoJSON

Skipped.

## Raster Images

No need as choropleth maps use vector data. 

## Working with projections in Leaflet

For advanced use! 

The Leaflet package expects all point, line, and shape data to be specified in latitude and longitude using `r glossary("WGS84")` (a.k.a. `r glossary("EPSG")`:4326). By default, when displaying this data it projects everything to [EPSG:3857](https://spatialreference.org/ref/epsg/3857/) and expects that any map tiles are also displayed in EPSG:3857.

For users that need to display data with a different projection, we’ve integrated the [Proj4Leaflet](https://github.com/kartena/Proj4Leaflet) plugin, which in theory gives Leaflet access to any `r glossary("CRS")` that is supported by [Proj4js](http://proj4js.org/).

Note that whatever map tiles you use they must be designed to work with the CRS of your Leaflet map.

(I stopped here, because I do not know if I will need this advanced and detailes information.)

## Using Leaflet with Shiny

::: {.callout-important #imp-042-using-leaflet-with-shiny}
###### My plan is to use {**leaflet**} with {**shiny**}

This is article is of special interest for me, because I am planning a Shiny dashboard where the map displays are provided by {**leaflet**}.
:::

### Introduction

The Leaflet package includes powerful and convenient features for integrating with Shiny applications.

Most Shiny output widgets are incorporated into an app by including an output (e.g., `shiny::plotOutput())` for the widget in the UI definition, and using a render function (e.g., `shiny::renderPlot())` in the server function. Leaflet maps are no different; in the UI you call `leaflet::leafletOutput()`, and on the server side you assign a `leaflet::renderLeaflet()` call to the output. Inside the `leaflet::renderLeaflet()` expression, you return a Leaflet map object.


::: {.column-page-inset}

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-042-leaflet-shiny-demo}
: {**leaflet**} with {**shiny**} demonstration
::::::
:::
::::{.my-r-code-container}

```{shinylive-r}
#| standalone: true
#| viewerHeight: 550
#| components: [editor, viewer]


library(shiny)
library(leaflet)

### don't need the next two lines
# r_colors <- rgb(t(col2rgb(colors()) / 255))
# names(r_colors) <- colors()

ui <- fluidPage(
  leafletOutput("mymap"),
  p(),
  actionButton("recalc", "New points")
)

server <- function(input, output, session) {

  points <- eventReactive(input$recalc, {
    cbind(rnorm(40) * 2 + 13, rnorm(40) + 48)
  }, ignoreNULL = FALSE)

  output$mymap <- renderLeaflet({
    leaflet() |> 
      addProviderTiles(providers$CartoDB.Positron,
        options = providerTileOptions(noWrap = TRUE)
      )  |> 
      addMarkers(data = points())
  })
}

shinyApp(ui, server)
```


::::
:::::
::: 

### Modifying Existing Maps with `leafletProxy`

The code in @cnj-042-leaflet-shiny-demo works, but reactive inputs and expressions that affect the `leaflet::renderLeaflet()` expression will cause the entire map to be redrawn from scratch and reset the map position and zoom level.

For some situations that may be acceptable or desirable behavior. But in other situations, you may want finer-grained control over the map, such as changing the color of a single polygon or adding a marker at the point of a click – without redrawing the entire map.

To modify a map that’s already running in the page, you use the `leaflet::leafletProxy()` function in place of the `leaflet::leaflet()` call, but otherwise use Leaflet function calls as normal.

Normally you use {**leaflet**} to create the static aspects of the map, and `leaflet::leafletProxy()` to manage the dynamic elements, like so:

::: {.column-page-inset}

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-042-using-leafletproxy}
: Static and dynamic procedures for a Leaflet map in Shiny
::::::
:::
::::{.my-r-code-container}


```{shinylive-r}
#| standalone: true
#| viewerHeight: 550
#| components: [editor, viewer]

library(shiny)
library(leaflet)
library(RColorBrewer)

r_colors <- rgb(t(col2rgb(colors()) / 255))
names(r_colors) <- colors()

ui <- bootstrapPage(
  tags$style(type = "text/css", "html, body {width:100%;height:100%}"),
  leafletOutput("map", width = "100%", height = "100%"),
  absolutePanel(top = 10, right = 10,
    sliderInput("range", "Magnitudes", min(quakes$mag), max(quakes$mag),
      value = range(quakes$mag), step = 0.1
    ),
    selectInput("colors", "Color Scheme",
      rownames(subset(brewer.pal.info, category %in% c("seq", "div")))
    ),
    checkboxInput("legend", "Show legend", TRUE)
  )
)

server <- function(input, output, session) {

  # Reactive expression for the data subsetted to what the user selected
  filteredData <- reactive({
    quakes[quakes$mag >= input$range[1] & quakes$mag <= input$range[2],]
  })

  # This reactive expression represents the palette function,
  # which changes as the user makes selections in UI.
  colorpal <- reactive({
    colorNumeric(input$colors, quakes$mag)
  })

  output$map <- renderLeaflet({
    # Use leaflet() here, and only include aspects of the map that
    # won't need to change dynamically (at least, not unless the
    # entire map is being torn down and recreated).
    leaflet(quakes) |> addTiles()  |> 
      fitBounds(~min(long), ~min(lat), ~max(long), ~max(lat))
  })

  # Incremental changes to the map (in this case, replacing the
  # circles when a new color is chosen) should be performed in
  # an observer. Each independent set of things that can change
  # should be managed in its own observer.
  observe({
    pal <- colorpal()

    leafletProxy("map", data = filteredData())  |> 
      clearShapes() |> 
      addCircles(radius = ~10^mag/10, weight = 1, color = "#777777",
        fillColor = ~pal(mag), fillOpacity = 0.7, popup = ~paste(mag)
      )
  })

  # Use a separate observer to recreate the legend as needed.
  observe({
    proxy <- leafletProxy("map", data = quakes)

    # Remove any existing legend, and only if the legend is
    # enabled, create a new one.
    proxy  |>  clearControls()
    if (input$legend) {
      pal <- colorpal()
      proxy |> addLegend(position = "bottomright",
        pal = pal, values = ~mag
      )
    }
  })
}

shinyApp(ui, server)
```

::::
:::::

::: 

::: {.callout-caution #cau-042-example-not-working}

####### @cnj-042-using-leafletproxy is not working

The code chunk does not generate an error, but the example does not show the colored earthquakes bubbles and legend. It does not react to changes from the UI.

I didn't yet try to debug the code. The content of the example is not important for me. It is the general idea that counts and the idea I have understood.

:::


::: {.callout-note #nte-042-conclusion}
##### Complex code with simple central idea

@cnj-042-using-leafletproxy is a complex example, but the main idea is pretty clear: 

- For all parts of the leaflet map, that will not be changed with Shiny controls use `leaflet::leaflet()` inside `leaflet::renderLeaflet()`. 
- For all the dynamic parts of the map, e.g., those parts that could be changed through the UI use `leaflet::leafletProxy()` inside an observer.
:::


## Glossary Entries {.unnumbered}

```{r}
#| label: glossary-table
#| echo: false

glossary_table()
```

------------------------------------------------------------------------

## Session Info {.unnumbered}

::::: my-r-code
::: my-r-code-header
Session Info
:::

::: my-r-code-container
```{r}
#| label: session-info

sessioninfo::session_info()
```
:::
:::::
