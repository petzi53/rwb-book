# Dashboard (1) {#sec-chap061}


```{r}
#| label: setup
#| results: hold
#| include: false

base::source(file = "R/helper.R")
ggplot2::theme_set(ggplot2::theme_bw())
```


::::: {#obj-chap061}
:::: {.my-objectives}
::: {.my-objectives-header}
Objectives
:::

::: {.my-objectives-container}

In this chapter I will learn to use the {**bslib**} package to create a Shiny dashboard for my `r glossary("RWB")` project.



:::
::::
:::::

## Functionality

I am thinking on a dashboard with the following functionalities:

1. Central are three display modes:
    - **Map**: Presenting maps, similar as on the [RSF Homepage](https://rsf.org/en/index).
    - **Chart**: Presenting chars to show the development over the years. There is no equivalent at the RSF website. You can see an example at the `r glossary("WHR")` Dashboard under the [subsection "Charts"](https://data.worldhappiness.report/chart). 
    - **Country** Presenting details about a specific country. Again the RSF website has no equivalence, but you got an idea after choosing a particular country under the subsection "Countries". See as an [example Austria](https://data.worldhappiness.report/country/AUT).
2. These three modes are essentially different, because they need diverse additional information (parameters):
    1. **Map Mode**:
        - `Year`: Allow only one year for map.
        - `Score`: One of the available scores:    
            - The *global score* for the years 2013-2025.   
            - The *components scores* for the years 2022-2025.   
        - `Ranking`: Not allowed (or later perhaps a map of the ranking differences between two years?)
        - `Region`: is allowed with map mode, but takes the chosen map and zooms into the selected region. Similar as in [WHR website](https://data.worldhappiness.report/map) by choosing "Map" and the select by "Filter by region".
        - `Country`: Select one or more of the available countries (because filtered by region was choose, then only the countries of this region are eligible.
    2. **Chart Mode**:
        - `Year`: Default is all available years, but the user can alternatively (de)select years.
        - `Score`: One of the available scores:    
            - The *global score* for the years 2013-2025 (default), but (de)selecting years is possible.  
            - The *components scores* for the years 2022-2025 (default), but (de)selecting years is possible.
        - `Ranking`: Alternatively with `Score` All year is default, but (de)selecting years is possible. 
        - `Region`: One region is eligible. Default is all countries.
        - `Country`: One or more countries are eligible. If a region is filtered then one can add other countries or deselect some countries from the region.
    3. **Country**: Overview about different parameters. Which parameters is still to decide. First approximation (see [example Austria](https://data.worldhappiness.report/country/AUT)):
        - All three modes are not available!
            - `Score chart`: Global and component scores over all available years
            - `Ranking chart`: Global and component rankings over all available years
            - `Value boxes`: Current, highest, lowest, average, medium, biggest climb, biggest fall (only rankings and global score)
            
## Design

I am condensing the most important section for my project of the {**bslib**} [Dashboard](https://rstudio.github.io/bslib/articles/dashboards/index.html) article.

### Plainest Design

There only three layout elements available in the standard layout: 

- the *title*, 
- the *sidebar* for the controls and 
- the *main content* area.

::: {.column-page}

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-061-dashboard-most-simple}
: UI elements of the most simple dashboard
::::::
:::
::::{.my-r-code-container}


```{shinylive-r}
#| standalone: true
#| viewerHeight: 350
#| components: [editor, viewer]

library(shiny)
library(bslib)

ui <- page_sidebar(
  title = "Title for the dashboard",
  sidebar = "Sidebar for the contols (input)",
  "Main content area"
)

shinyApp(ui, function(input, output) {})
```


::::
:::::

::: 

::: {.callout-tip #tip-061-shinylieve-interaction}
##### How to interact with the `shinylive-r` output?

In the above first example there is only a minimal interaction possible. Clicking on the right top arrow in the sidebar (**<**) will close the sidebar and therefore enlarge the main content area. 
But in this {**shinylive**} mode you can also change the code and rerun the program by clicking on the top right filled arrow (▶). Try it out to change one of the text strings.
:::

### Minimum content

> Both the `sidebar` and main content areas can hold any arbitrary collection of UI elements, but it’s good practice to keep inputs in the `sidebar` and outputs in the main content area. Also, consider wrapping outputs in a `card()` and sidebar contents in a `sidebar()` object to add a `title` and/or customize styling, positioning, etc.

::: {.column-page}

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-061-dashboard-most-simple}
: UI elements of the most simple dashboard
::::::
:::
::::{.my-r-code-container}


```{shinylive-r}
#| standalone: true
#| viewerHeight: 500
#| components: [editor, viewer]

library(shiny)
library(bslib)

ui <- page_sidebar(
  title = "Title for the whole dashboard",
  sidebar = sidebar(
    title = "Controls / Input"
  ),
  card(
    card_header("Title for the current card"),
    textOutput("txt")
  )
)

server <-  function(input, output) {
  output$txt <- renderText({
    "This is the main area (of the card)"
  })
}

shinyApp(ui, server)
```


::::
:::::

::: 

Even with the minimum card content we needed about 15 code lines. This is just a simple template. All parts can be arbitrary complex 
- `title()` could be for example a complex expression
- `sidebar()` can hold many input controls and directives for the layout (e.g., several cards in a specific arrangement),
- `card()` can hold complex results and 
`server()` is the most tricky part, because it needs reactivity (`reactive()` functions) to work together with the input controls.



::: {.callout-tip #tip-061-minimum-as-template}
###### Minimum content as template

I have developed a template as an `r glossary("snippet", "RStudio snippet")` with the minimum content example. I am using it to start new Shiny apps or a `shinylive-r` code chunks.
:::


I will stop here with the minimum content example. It works as a template for new apps resp. `shinylive-r` code chunks. But there are still to cover many other {**bslib**} design features and functions. Whenever the need arises I will either come back here to this section or write my notes in the appropriate project section. 


## RWB Line Chart / One Country

In the {**bslib**} documentation there is a basic example of a customizable histogram with numeric variables from the {**palmerpenguins**} dataset. I will use my own `rwb` dataset to display different line charts for global scores and rankings for selected countries or regions.

My aim is to go step by step from the simple to the more complex, e.g. to start with a line chart for one country and one variable, followed for several variables and finally with several countries. For my own learning purpose I will also use four different modes:

| Program | Helper | Shiny | Abbr. |
|---------|--------|-------|-------|
| ggplot2 | only   | ----- | GO0   |
| plotly  | only   | ----- | PO0   |
| ggplot2 | with   | Shiny | GWS   |
| plotly  | with   | Shiny | PWS   |
: Four modes with rising complexity {#tbl-modes} {.striped}


The final product should always be an interactive graph using {**plotly**} in an web application environment controlled by {**shiny**} PWS.

In the first try I will not give attention to legend and theme but one: `theme_set(theme_bw())` 

::: {.callout-important #imp-061-rw-project-rules}
###### Conventions

To facilitate learning I will apply in this book three conventions:

1. To get a better overview of all necessary code lines, I will load the necessary data, functions and packages in every code chunk.
2. To make it easier for references I will not use [Quarto tabsets](https://quarto.org/docs/output-formats/html-basics.html#tabsets), because only the content of the visible tab can be cross referenced.
3. I will develop the `shinylive-r` code chunks in as separate Shiny app because then I have all available the debug tools. Then I will include the content of the finished app into the `shinylive-r` code chunk with

`## file: app.R`     
`{{< include path-to/app.R >}}`


:::

### GO0 Line Chart

The easiest line chart is a graph showing the development of one variable over the years for one country. I will take the variable `score` for the global score showing the trend for my own country Austria (`country_en == "Austria`). 

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-061-go0-line-chart}
: `GO0` Using {ggplot2} (without Shiny) for a line chart
::::::
:::
::::{.my-r-code-container}
```{r}
#| label: go0-line-chart
#| lst-label: lst-go0-line-chart
#| fig-cap: "Development of the global World Press Freedom Index (WPFI) of Austria with `ggplot()`: `GO0`"
#| lst-cap: "One numeric variable (Score) with one factor variable (Country Name) using `ggplot()`: `GO0`"

library(ggplot2)
library(dplyr, warn.conflicts = FALSE)

rwb <- readRDS(paste0(here::here(), "/data/chap011/rwb/rwb.rds"))

p <- rwb |> 
  select(year_n, country_en, score) |> 
  filter(country_en == "Austria") |> 
  na.omit() |>
  ggplot(aes(year_n, score)) +
    geom_line()

p
```

::::
:::::

### PO0 Line Chart

The UI is identical with @cnj-061-line-chart-gws-1. There are two ways to create a {**plotly**} line chart:

1. **Convert `ggplot()` to `plotly()`**. This requires only one changes: Encapsulate the `ggplot2::ggplot()` object with `plotly::ggplotly()`.
2. **Build a `plot_ly()` graph from scratch**. For me this requires to learn another syntax because my experience with {**plotly**} is currently very limited. But using this direct approach has some advantages:
  - **Performance**: This is the primary limitation of `ggplotly()` compared to the native `plot_ly()`. The difference is huge: Depending on the graph `ggplotly()` is [23-143 (!) times slower](https://www.jumpingrivers.com/blog/comparing-plotly-ggplotly-plot-generation-times/) than `plot_ly()`.
  - **Customization**: The outcome of `ggplotly()`is not always predictable and there is less control about the final graph compared with the native `plot_ly()` function.
  
:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-061-ggplotly-line-chart}
: `PO0`: Line chart with `ggplot()` and `ggplotly()` (without Shiny).
::::::
:::
::::{.my-r-code-container}
```{r}
#| label: ggplotly-line-chart
#| lst-label: lst-061-ggplotly-line-chart
#| lst-cap: "Line chart with `ggplot()` and `ggplotly()`"
#| fig-cap: "Development of the global World Press Freedom Index (WPFI) of Austria with `ggplot()` and `ggplotly()`: `GO0`"

library(plotly, warn.conflicts = FALSE)
library(dplyr, warn.conflicts = FALSE)

rwb <- readRDS(paste0(here::here(), "/data/chap011/rwb/rwb.rds"))

p <- rwb |> 
  select(year_n, country_en, score) |> 
  filter(country_en == "Austria") |> 
  na.omit() |>
  ggplot(aes(year_n, score)) +
    geom_line()

ggplotly(p)
```

::::
:::::
  
  
:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-061-po0-line-chart}
: `PO0` Using {plotly} (without Shiny) for a line chart
::::::
:::
::::{.my-r-code-container}
```{r}
#| label: po0-line-chart
#| lst-label: lst-po0-line-chart
#| fig-cap: "Development of the global World Press Freedom Index (WPFI) of Austria with {plotly}: `PO0`"
#| lst-cap: "One numeric variable (Score) with one factor variable (Country Name) using {plotly}: `GO0`"

library(plotly, warn.conflicts = FALSE)
library(dplyr, warn.conflicts = FALSE)

rwb <- readRDS(paste0(here::here(), "/data/chap011/rwb/rwb.rds"))

p <- rwb |> 
  select(year_n, country_en, score) |> 
  filter(country_en == "Austria") |> 
  na.omit() |>
  plot_ly(
    x = ~year_n, 
    y = ~score, 
    type = 'scatter', 
    mode = 'lines')
p
```

::::
:::::

::: {.callout-note #nte-061-suppress-warnings}
###### How to suppress warnings?

During the process of loading and attaching the two packages ({**dplyr**} and {**plotly**}) I have used `warn.conflicts = FALSE` to suppress warnings. This is special for these two packages. A general command would have been `base::suppressWarnings()`.
:::

### GWS Line Chart

Now I have to think about the input control(s) for the user. In this first simple example I will only provide to choose one country, specifically only *one* country. The variable is with `score` still the same.


::: {.column-screen}
:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-061-line-chart-gws-1}
: `GWS` Choose country to display WPFI for all available years
::::::
:::
::::{.my-r-code-container}

```{shinylive-r}
#| standalone: true
#| viewerHeight: 800
#| components: [editor, viewer]
#| layout: vertical

## file: app.R
{{< include app-061-line-chart-gws-1/app.R >}}

```

::::
:::::

:::

::: {.callout-important #imp-061-load-dataset}
##### Loading files in Shinylive apps in Quarto

I had problems to work with my RWB dataset. For `shinylive-r` code chunks is a special procedure necessary to load external data files: There are three ways to include files:

1. You can embed text files in the code blocks. Not appropriate for me because `rwb` is a binary file.
2. You can also embed binary files with a different procedure in the code blocks. But this option didn't work for me.
3. Load the file via a http request. This worked for me.

See [Shinylive: Load file](https://github.com/quarto-ext/shinylive/blob/main/load_file.qmd)

**How to include .rds file in shinylive** (from Brave KI)

To include an `.rds` file in a Shiny app hosted on the internet, you can load it directly from a public URL using the `readRDS` function combined with `gzcon` and `url` to handle the remote data stream. This method allows you to access the file without needing to download it locally first.

For example, if the `.rds` file is hosted on a public repository like GitHub, you can use the raw file URL:

```r
data <- readRDS(gzcon(url("https://raw.githubusercontent.com/username/repo/main/data/file.rds")))
```

This approach works because `url()` creates a connection to the remote file, `gzcon()` decompresses it if necessary, and `readRDS()` reads the R object from the connection  This method is particularly useful for deploying Shiny apps on platforms like shinyapps.io, where you can host the data file publicly and reference it directly in your app's server logic 

Alternatively, you can create a helper function to manage the remote loading process, which saves the file to a temporary local location before reading it, ensuring compatibility and reliability:

```r
readRDS_remote <- function(file, quiet = TRUE) {
  if (grepl("^http", file, ignore.case = TRUE)) {
    file_local <- file.path(tempdir(), basename(file))
    download.file(file, file_local, quiet = quiet, mode = "wb")
    file <- file_local
  }
  readRDS(file)
}
```

Then use it as:

```r
data <- readRDS_remote("https://example.com/data/file.rds")
```

This method is beneficial when dealing with large files or unreliable connections, as it ensures the file is fully downloaded before being read.

:::


In addition to the line chart I have added two customizations:

1. I added ggplot2::geom_point() on top of ´ggplot2::geom_line. The result is a [connected scatterplot](https://r-graph-gallery.com/connected_scatterplot_ggplot2.html). The page on the [R Graph Gallayer](https://r-graph-gallery.com) show other adaption as well, like custom circles and lines with arguments like `shape`, `size`, `color` and more.
2. I added a dynamic title for the card container. The somewhat tricky part of this change is that you have to use the `paste()` function to put the static and dynamic parts of text string together in a reactive function (and not in UI).

### PWS Line Chart

#### Using `ggploty()`

Converting a `ggplot()` to `plotly()` in a Shiny app requires three changes: 

- Encapsulate the `ggplot2::ggplot()` object with `plotly::ggplotly()`. This is the same change as in @lst-061-ggplotly-line-chart without Shiny. But there are other two additions necessary:
(1) Change `plotOutput()` to `plotlyOutput()` and to
(2) Change `renderPlot()` to `renderPlotly()`.


::: {.column-screen}
:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-061-line-chart-pws-1a}
: `PWS` Choose country to display WPFI for all available years with `ggplotly()`
::::::
:::
::::{.my-r-code-container}

```{shinylive-r}
#| standalone: true
#| viewerHeight: 800
#| components: [editor, viewer]
#| layout: vertical

## file: app.R
{{< include app-061-line-chart-pws-1a/app.R >}}

```

::::
:::::
:::

#### Using `plot_ly()`

The second possibility is to use the native mode to {**plotly**}: Instead of converting a {**ggplot2**} graph to {**plotly**} we generate the interactive graph with `plotly::plot_ly()`.

As this is the more convenient approach to build interactive graphs for complex figures and dashboards computing several charts in parallel, from now on I will only display the native `plot_ly()` variant.

::: {.column-screen}
:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-061-line-chart-pws-1b}
: `PWS` Choose country to display WPFI for all available years with `plot_ly()`.
::::::
:::
::::{.my-r-code-container}

```{shinylive-r}
#| standalone: true
#| viewerHeight: 800
#| components: [editor, viewer]
#| layout: vertical

## file: app.R
{{< include app-061-line-chart-pws-1b/app.R >}}

```

::::
:::::

:::

::: {.callout-important #nte-061-scatter-syntax}
###### Some comments on the `plot_ly()` syntax

1. Note that the `x` and `y` variable need in front the `~` sign. These are the data visualized as scatter point or lines in the `x` and `y` variable. 
2. Type `scatter` is a fundamental type for creating various visualizations such as scatter plots, line charts, but is also used for text and bubble charts. 
3. The `mode` attribute determines how the data is displayed, such as with markers, lines, text, or a combination of these. For example, setting `mode = "line"` creates a standard line plot as in @lst-po0-line-chart, while `mode = "lines+markers"` adds both lines connecting the points and markers at each point as in @cnj-061-line-chart-pws-1b.


:::

:::::{.my-resource}
:::{.my-resource-header}
:::::: {#lem-061-scatter-syntax}
: How to build line and scatter plots with {**plotly**}
::::::
:::
::::{.my-resource-container}

- [Examples for scatter and line plots](https://plotly.com/r/line-and-scatter/) can be found on the Plotly pages. 
- The [reference page on scatter](https://plotly.com/r/reference/scatter/) shows that the `scatter`type has a rich set of customization options.
- For a more comprehensive instruction how to use the {**plotly**} R package read the authoritative resource [Interactive web-based data visualization with R, plotly, and shiny](https://plotly-r.com/) by Carson Sievert [@sievert2019].

::::
:::::

## RWB Line Charts / Several Countries

### One country after the other

::: {.column-screen}
:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-061-line-chart-pws-2}
: Show development of WPFI for several countries at once
::::::
:::
::::{.my-r-code-container}
```{shinylive-r}
#| standalone: true
#| viewerHeight: 800
#| components: [editor, viewer]
#| layout: vertical

## file: app.R
{{< include app-061-line-chart-pws-2/app.R >}}

```

::::
:::::
::: 

There are several important comments to make:

1. At first I tried to disntinguish between the first trace (with `plot_ly()`) and all the other traces with `add_trace()`. But it turned out that I just need to set the argument `color` to the country vector.

2. I had to adapt the card title so that it can display all names of the displayed countries.

3. A big drawback is that the line color of the already chosen countries changes after another country is selected. So far I couldn't find a solution. After my question was [in StackOverflow not accepted](https://stackoverflow.com/questions/79757537/how-to-control-line-chart-colors-in-plotly-when-lines-are-added-via-shinyselec) (supposedly because it is a duplicate of another question), I posted in the [Posit Forum](https://forum.posit.co/t/how-to-control-line-chart-colors-in-plotly-when-lines-are-added-via-shiny-selectinput/206923) for help.

### With `actionButton()`

A different UI would be adding an action button to delay the reaction. In this case the complete chart with all the chosen countries is drawn. So there is no irritation.

But in the next step when adding or removing the same problem recurs. Adding just one country results again in a distracting experience. It is a slighlty better whenever several countries are added, removed or changed.

::: {.column-screen}
:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-061-line-chart-pws-3}
: Show development of WPFI with delayed reaction via action button
::::::
:::
::::{.my-r-code-container}
```{shinylive-r}
#| standalone: true
#| viewerHeight: 800
#| components: [editor, viewer]
#| layout: vertical

## file: app.R
{{< include app-061-line-chart-pws-3/app.R >}}

```

::::
:::::
::: 


## Glossary Entries {.unnumbered}

```{r}
#| label: glossary-table
#| echo: false

glossary_table()
```

------------------------------------------------------------------------

## Session Info {.unnumbered}

::: my-r-code
::: my-r-code-header
Session Info
:::

::: my-r-code-container
```{r}
#| label: session-info

xfun::session_info()
```
:::
:::

